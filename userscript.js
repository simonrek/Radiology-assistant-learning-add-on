/** @format */

// ==UserScript==
// @name         Radiology Assistant Personal Tutor
// @namespace    https://github.com/simonrek/radiology-assistant-personal-tutor
// @version      0.1.0
// @description  GDPR-conscious AI-powered personal tutor for enhanced learning on Radiology Assistant - track progress, get tested, and maximize learning efficiency with Mistral AI
// @author       Simon Rekanovic
// @homepage     https://github.com/simonrek/radiology-assistant-personal-tutor
// @supportURL   https://github.com/simonrek/radiology-assistant-personal-tutor/issues
// @updateURL    https://raw.githubusercontent.com/simonrek/radiology-assistant-personal-tutor/main/userscript.meta.js
// @downloadURL  https://raw.githubusercontent.com/simonrek/radiology-assistant-personal-tutor/main/userscript.js
// @match        https://radiologyassistant.nl/*
// @exclude      https://radiologyassistant.nl/
// @exclude      https://radiologyassistant.nl/index*
// @grant        GM.setValue
// @grant        GM.getValue
// @grant        GM.deleteValue
// @grant        GM.listValues
// @grant        GM.addStyle
// @grant        GM.xmlHttpRequest
// @connect      api.mistral.ai
// @run-at       document-end
// @license      MIT
// ==/UserScript==

// ========================================
// 🔧 CROSS-PLATFORM USERSCRIPT ENGINE
// ========================================
// Compatible with: Safari Userscripts, Tampermonkey
// Uses modern async GM.* API supported by all platforms
console.log("🔧 Cross-platform userscript engine loaded")
;(function () {
  "use strict"

  // ========================================
  // 🔧 USER CONFIGURABLE SETTINGS - MODIFY THESE AS NEEDED
  // ========================================

  // IMPORTANT: These settings can be safely modified by users
  // No personal data is collected or transmitted outside your browser

  const USER_CONFIG = {
    // ═══════════════════════════════════════
    // AI SETTINGS (Solution was built in Europe - therefore Mistral AI Only)
    // ═══════════════════════════════════════
    MISTRAL_API_KEY: "", //API key later added by user (stored locally only)
    AI_MODEL: "mistral-medium-latest", // Mistral model to use

    // ═══════════════════════════════════════
    // PRICING CONFIGURATION (EUR per 1K tokens)
    // ═══════════════════════════════════════
    PRICING: {
      // Mistral pricing as of August 2025 (per 1K tokens in EUR)
      "mistral-small-latest": {
        input: 0.0001, // €0.0001 per 1K input tokens (€0.1/M tokens)
        output: 0.0003, // €0.0003 per 1K output tokens (€0.3/M tokens)
      },
      "mistral-medium-latest": {
        input: 0.0004, // €0.0004 per 1K input tokens (€0.4/M tokens)
        output: 0.002, // €0.002 per 1K output tokens (€2.0/M tokens)
      },
      "mistral-large-latest": {
        input: 0.0018, // €0.0018 per 1K input tokens (€1.8/M tokens)
        output: 0.0054, // €0.0054 per 1K output tokens (€5.4/M tokens)
      },
      // Default fallback pricing (using Small model rates)
      default: {
        input: 0.0001,
        output: 0.0003,
      },
    },

    // ═══════════════════════════════════════
    // USER INTERFACE SETTINGS
    // ═══════════════════════════════════════
    TUTOR_PANEL_OPEN_BY_DEFAULT: true, // Start with panel open

    // ═══════════════════════════════════════
    // DATA STORAGE SETTINGS (All Local - GDPR Compliant)
    // ═══════════════════════════════════════
    SAVE_PROGRESS_LOCALLY: true, // Save progress in browser storage
    USE_GM_STORAGE_ONLY: true, // Use only GM storage for consistency
    DATA_RETENTION_DAYS: 365, // How long to keep local data
  }

  // ========================================
  // 🔒 PRIVACY & GDPR AWARENESS NOTICE
  // ========================================
  // This userscript is designed with data protection in mind and to be GDPR compliant:
  // ✅ NO personal data collection
  // ✅ NO data transmission except to Mistral AI for summary, answer or quiz generation - no personal data included
  // ✅ ALL usage data stored locally in your browser only
  // ✅ NO tracking, cookies, or external analytics
  // ✅ ALL data generated by the app can be deleted anytime by the user, no data is sent to external servers

  // ========================================
  // 🎛️ INTERNAL CONFIGURATION (DO NOT MODIFY)
  // ========================================
  const CONFIG = {
    // Copy user settings for internal use
    ...USER_CONFIG,

    // Mistral AI Configuration
    MISTRAL_BASE_URL: "https://api.mistral.ai/v1",
    MISTRAL_DEFAULT_MODEL: USER_CONFIG.AI_MODEL || "mistral-small-latest",

    // Storage configuration
    STORAGE_PREFIX: "ra_tutor_gdpr_",

    // Privacy settings
    NO_PERSONAL_DATA: true,
    GDPR_COMPLIANT: true,
  }

  // ========================================
  // 🎨 STYLING
  // ========================================
  const CSS_STYLES = `
        /* Tutor Panel Styles - Content only, positioning handled by JS */
        #ra-tutor-panel {
            border-left: 0px solid #2c497c00;
        }

        .tutor-header {
            background: linear-gradient(135deg, #7198f8 0%, #5577e6 100%);
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .tutor-content {
            padding: 10px;
            height: calc(100vh - 200px); /* Account for header, settings, and footer */
            overflow-y: auto;
            background: #12326200;
            padding-bottom: 10px; /* Reduced since settings section provides buffer */
        }

        .tutor-tab {
            display: none;
        }

        .tutor-tab.active {
            display: block;
        }

        .tab-buttons {
            display: flex;
            background: #1a3a6b;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            border: 1px solid #2c4a7c;
        }

        .tab-button {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            color: #b0bec5;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-button:hover {
            background: #2c4a7c;
            color: #7198f8;
        }

        .tab-button.active {
            background: #7198f8;
            color: white;
        }

        .progress-item {
            background: #1a3a6b;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #7198f8;
            color: #e8eaed;
        }

        .progress-item strong {
            color: #7198f8;
        }
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab-button.active {
            background: #7198f8;
            color: white;
        }

        .quiz-question {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .quiz-options {
            margin-top: 15px;
        }

        .quiz-option {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-option:hover {
            background: #f0f8ff;
            border-color: #667eea;
        }

        .ai-response {
            background: linear-gradient(135deg, #e0f2fe 0%, #b3e5fc 100%);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border-left: 4px solid #03a9f4;
        }

        /* Dark mode styles */
        .dark-mode #ra-tutor-panel {
            background: linear-gradient(145deg, #2d3748, #1a202c);
            border-color: #4a5568;
            color: white;
        }

        .dark-mode .tutor-content {
            color: white;
        }

        .dark-mode .progress-item {
            background: #4a5568;
            color: white;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            #ra-tutor-panel {
                width: 320px;
            }
            
            #ra-tutor-toggle {
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
        }

       
        }
    `

  // ========================================
  // 💾 GDPR-conscious DATA MANAGEMENT
  // ========================================
  class DataManager {
    constructor() {
      this.storagePrefix = CONFIG.STORAGE_PREFIX

      console.log(
        "🔒 Initializing GM-only data storage (no external transmission)"
      )
    }

    // Save data locally only (no external transmission)
    async saveData(key, data) {
      try {
        console.log(`🔒 Saving data for key: ${key}`, data)

        if (!CONFIG.SAVE_PROGRESS_LOCALLY) {
          console.log("🔒 Data saving disabled by user configuration")
          return
        }

        let gdprData
        if (Array.isArray(data)) {
          // For arrays, add metadata without converting to object
          gdprData = [...data] // Create a copy of the array
          gdprData._gdpr_stored = Date.now()
          gdprData._gdpr_local_only = true
          gdprData._gdpr_no_personal_data = true
        } else {
          // For objects, spread normally
          gdprData = {
            ...data,
            _gdpr_stored: Date.now(),
            _gdpr_local_only: true,
            _gdpr_no_personal_data: true,
          }
        }

        // Always use GM storage for consistency
        const fullKey = this.storagePrefix + key
        console.log(`🔒 Using GM.setValue for key: ${fullKey}`)
        await GM.setValue(fullKey, gdprData)

        console.log(`🔒 Data saved locally for key: ${key}`)
      } catch (error) {
        console.error("🔒 Error saving local data:", error)
      }
    }

    //Load data from local storage only
    async loadData(key, defaultValue = null) {
      try {
        console.log(`🔒 Loading data for key: ${key}`)

        // Always use GM storage for consistency
        const fullKey = this.storagePrefix + key
        console.log(`🔒 Using GM.getValue for key: ${fullKey}`)
        const data = await GM.getValue(fullKey, null)
        console.log(`🔒 GM.getValue result:`, data)

        console.log(`🔒 Loaded data for key ${key}:`, data)

        if (data) {
          // Check data retention policy
          if (this.isDataExpired(data)) {
            console.log(`🔒 Data expired for key ${key}, removing`)
            await this.deleteData(key)
            return defaultValue
          }

          // Remove privacy metadata before returning
          if (Array.isArray(data)) {
            // For arrays, remove metadata properties and return the array
            const cleanArray = [...data]
            delete cleanArray._gdpr_stored
            delete cleanArray._gdpr_local_only
            delete cleanArray._gdpr_no_personal_data
            return cleanArray
          } else {
            // For objects, use destructuring
            const {
              _gdpr_stored,
              _gdpr_local_only,
              _gdpr_no_personal_data,
              ...cleanData
            } = data
            return cleanData
          }
        }

        console.log(
          `🔒 No data found for key ${key}, returning default:`,
          defaultValue
        )
        return defaultValue
      } catch (error) {
        console.error("🔒 Error loading local data:", error)
        return defaultValue
      }
    }

    // GDPR: Delete local data
    async deleteData(key) {
      try {
        console.log(`🔒 Deleting data for key: ${key}`)

        // Always use GM storage for consistency
        const fullKey = this.storagePrefix + key
        await GM.deleteValue(fullKey)

        console.log(`🔒 Local data deleted for key: ${key}`)
      } catch (error) {
        console.error("🔒 Error deleting local data:", error)
      }
    }

    // GDPR: Get all locally stored keys
    async getAllKeys() {
      try {
        console.log("🔧 getAllKeys: Getting all GM storage keys...")

        const allGMKeys = await GM.listValues()
        console.log("🔧 getAllKeys: All GM keys found:", allGMKeys)

        const filteredKeys = allGMKeys.filter(key =>
          key.startsWith(this.storagePrefix)
        )
        console.log("🔧 getAllKeys: Filtered keys with prefix:", filteredKeys)

        return filteredKeys
      } catch (error) {
        console.error("🔒 Error getting local keys:", error)
        return []
      }
    }

    // GDPR: Clear all user data (right to erasure)
    async clearAllUserData() {
      try {
        console.log("🔒 GDPR: Clearing all user data...")

        const keys = await this.getAllKeys()
        console.log("🔒 GDPR: Found keys to delete:", keys)

        for (const fullKey of keys) {
          await GM.deleteValue(fullKey)
          console.log(`🔒 GDPR: Deleted key: ${fullKey}`)
        }

        console.log(
          "🔒 GDPR: All user data cleared (right to erasure exercised)"
        )
      } catch (error) {
        console.error("🔒 GDPR: Error clearing user data:", error)
      }
    }

    isDataExpired(data) {
      if (!data._gdpr_stored || !CONFIG.DATA_RETENTION_DAYS) {
        return false
      }

      const expiryTime =
        data._gdpr_stored + CONFIG.DATA_RETENTION_DAYS * 24 * 60 * 60 * 1000
      return Date.now() > expiryTime
    }
  }

  // ========================================
  // 🤖 MISTRAL AI TUTOR ENGINE - its where the magic happens 🦄
  // ========================================
  class AITutor {
    constructor() {
      this.apiKey = null
      this.model = CONFIG.MISTRAL_DEFAULT_MODEL
      this.baseURL = CONFIG.MISTRAL_BASE_URL
      this.currentContext = ""

      // No personal data stored, only anonymous content analysis
      console.log("🔒 AI Tutor initialized with local-only data processing")
    }

    async initialize() {
      try {
        console.log("🔑 AITutor.initialize() starting...")
        // Get API key from user configuration or local storage
        this.apiKey =
          USER_CONFIG.MISTRAL_API_KEY ||
          (await GM.getValue("mistral_api_key", null))

        console.log("🔑 API key sources checked:", {
          fromConfig: Boolean(USER_CONFIG.MISTRAL_API_KEY),
          fromStorage: Boolean(await GM.getValue("mistral_api_key", null)),
          finalKey: Boolean(this.apiKey),
        })

        console.log(
          "🔒 AI Tutor API key loaded:",
          this.hasApiKey() ? "✅ Available" : "❌ Not configured"
        )
      } catch (error) {
        console.warn("🔒 Error loading API key:", error)
        this.apiKey = null
      }
    }

    hasApiKey() {
      const hasKey = Boolean(this.apiKey && this.apiKey.trim())
      console.log("🔑 hasApiKey() check:", {
        apiKeyExists: Boolean(this.apiKey),
        apiKeyLength: this.apiKey ? this.apiKey.length : 0,
        apiKeyTrimmed: this.apiKey ? this.apiKey.trim().length : 0,
        result: hasKey,
      })
      return hasKey
    }

    extractPageContent() {
      // Extract main content from the page
      const contentSelectors = [
        "article",
        ".content",
        "#content",
        "main",
        ".article-content",
        ".post-content",
      ]

      let content = ""
      for (const selector of contentSelectors) {
        const element = document.querySelector(selector)
        if (element) {
          content = element.innerText
          break
        }
      }

      // Fallback to body content if no specific container found
      if (!content) {
        const bodyClone = document.body.cloneNode(true)
        // Remove script and style tags
        bodyClone
          .querySelectorAll("script, style, nav, header, footer")
          .forEach(el => el.remove())
        content = bodyClone.innerText
      }

      // Clean and limit content
      content = content.replace(/\s+/g, " ").trim()
      // console.log('🔒 Extracted page content:', content)
      return content.substring(0, 50000) // Limit for API calls
    }

    async generateSummary(content, options = {}, forceBypassCache = false) {
      // Create page-specific unified response key
      const pageUrl = window.location.pathname
      const requestHash = this.getContentHash(
        JSON.stringify({ content: content.substring(0, 1000), options })
      )

      // Check unified storage first (unless bypassing cache)
      if (!forceBypassCache) {
        const existingResponses = await this.getPageAIResponses(
          pageUrl,
          "summary"
        )

        // Find cached summary with matching options (focus type, length, language)
        const focus = options.focus || "key_learning_points"
        const length = options.length || "short"
        const languageInstruction = options.languageInstruction || ""

        const matchingCached = existingResponses.find(response => {
          const reqOptions = response.request.options || {}
          return (
            (reqOptions.focus || "key_learning_points") === focus &&
            (reqOptions.length || "short") === length &&
            (response.request.languageInstruction || "") === languageInstruction
          )
        })

        if (matchingCached) {
          console.log("✅ Using cached unified summary with matching type", {
            pageUrl,
            focus,
            length,
            age: this.formatTimeAgo(matchingCached.timestamp),
          })
          return matchingCached.response.parsed
        } else {
          console.log("🔍 No matching cached summary found", {
            requestedFocus: focus,
            requestedLength: length,
            availableSummaries: existingResponses.length,
            availableTypes: existingResponses.map(r => ({
              focus: r.request.options?.focus || "key_learning_points",
              length: r.request.options?.length || "short",
            })),
          })
        }
      } else {
        console.log("🔄 Bypassing cache for fresh AI summary")
      }

      if (!this.apiKey) {
        throw new Error(
          "API key required for summary generation. Please configure your Mistral API key in the settings."
        )
      }

      try {
        console.log("🚀 Generating fresh AI summary via Mistral", {
          pageUrl,
          options,
          contentLength: content.length,
        })

        const length = options.length || "short"
        const focus = options.focus || "key_learning_points"
        const languageInstruction = options.languageInstruction || ""

        let prompt = this.buildSummaryPrompt(
          content,
          length,
          focus,
          languageInstruction
        )

        const response = await this.callMistralAPI(prompt, null, {
          type: "summary",
          pageUrl,
          focus,
          length,
        })

        if (response && response.content) {
          const summary = this.parseSummaryResponse(response.content)

          // � UNIFIED STORAGE ONLY: Store as AI response with metadata
          const responseKey = await this.storeAIResponse(
            pageUrl,
            "summary",
            {
              content: content.substring(0, 1000),
              options,
              languageInstruction,
            },
            { raw: response.content, parsed: summary },
            { model: this.model, contentLength: content.length }
          )

          console.log("✅ Summary generated and stored in unified system", {
            pageUrl,
            dynamicSections: summary._dynamicSections?.length || 0,
            responseKey: responseKey?.substring(0, 50) + "...",
          })

          return summary
        } else {
          throw new Error("Invalid response from Mistral AI")
        }
      } catch (error) {
        console.error("❌ Error generating AI summary:", error)
        throw error
      }
    }

    buildSummaryPrompt(content, length, focus, languageInstruction = "") {
      const lengthInstructions = {
        short: "Provide a concise short bullet point summary",
        medium: "Provide a medium detailed summary with 5-7 bullet point",
        long: "Provide a detailed point summary with explanations and emphasis on key concepts",
      }

      const focusInstructions = {
        key_learning_points:
          "Focus on the most important learning points and key concepts that residents should understand",
        clinical_overview:
          "Provide a short clinical recap focusing on practical diagnostic and management aspects",
        imaging_pearls:
          "Focus specifically on key imaging findings, techniques, diagnostic pearls, and what radiologists should look for",
        imaging_differential:
          "Focus on imaging-based differential diagnoses, key distinguishing features, and diagnostic decision-making in radiology",
        clinical_pearls:
          "Focus on clinical pearls, practical tips, and diagnostic insights",
        pathology:
          "Focus on pathological findings, imaging features, and differential diagnoses",
        treatment:
          "Focus on treatment approaches, management strategies, and clinical decisions",
      }

      // Create dynamic prompt based on focus type
      let specificInstructions = ""
      let responseStructure = ""

      switch (focus) {
        case "imaging_pearls":
          specificInstructions = `
- Emphasize imaging modalities, protocols, and technical considerations
- Highlight specific imaging findings and their significance
- Include tips for image interpretation and common pitfalls
- Focus on what makes imaging findings distinctive or pathognomonic`
          responseStructure = `{
  "keyPoints": ["imaging finding 1", "technique 2", "interpretation tip 3", ...],
  "imagingPearls": ["pearl 1", "pearl 2", ...],
  "technicalTips": ["tip 1", "tip 2", ...],
}`
          break

        case "imaging_differential":
          specificInstructions = `
- Focus on differential diagnoses based on imaging appearance
- Explain key distinguishing imaging features between conditions
- Include decision trees or diagnostic algorithms when applicable
- Emphasize imaging characteristics that help narrow the differential`
          responseStructure = `{
  "differentials": ["condition 1 with imaging features", "condition 2 with features", ...],
  "keyDistinguishers": ["feature 1", "feature 2", ...],
  "imagingApproach": ["step 1", "step 2", ...],
  
}`
          break

        case "clinical_overview":
          specificInstructions = `
- Provide a practical, resident-focused clinical summary
- Include both diagnostic and management considerations
- Keep it concise but comprehensive for quick review
- Focus on actionable clinical information`
          responseStructure = `{
  "clinicalPoints": ["point 1", "point 2", ...],
  "diagnosticApproach": ["step 1", "step 2", ...],
  "keyTakeaways": ["takeaway 1", "takeaway 2", ...],
  
}`
          break

        default:
          specificInstructions = `
- Include specific imaging findings, anatomical details, and clinical correlations when present
- Highlight differential diagnoses and key distinguishing features
- Balance theoretical knowledge with practical application`
          responseStructure = `{
  "keyPoints": ["point 1", "point 2", ...],
  "clinicalPearls": ["pearl 1", "pearl 2", ...],
  "differentials": ["diff 1", "diff 2", ...],
  
  "focusAreas": ["area1", "area2", ...]
}`
      }

      return `You are a senior radiology educator.

TASK: Create a ${focus.replace(
        /_/g,
        " "
      )} summary of this radiology content for radiology residents.

CONTENT: "${content.substring(0, 50000)}"

INSTRUCTIONS:
- ${lengthInstructions[length]}
- ${focusInstructions[focus] || focusInstructions.key_learning_points}
- Use clear and supportive educational language appropriate for medical learners${specificInstructions}
- Format as bullet points for easy learning
- Vary your approach and content based on the specific focus requested${languageInstruction}

RESPONSE FORMAT:
Provide your response as a JSON object with this structure:
${responseStructure}`
    }

    parseSummaryResponse(content) {
      // First, log the raw content to see what we're getting from AI
      console.log(
        "🤖 RAW AI Response (first 1000 chars):",
        content.substring(0, 1000)
      )
      console.log(
        "🤖 RAW AI Response (last 500 chars):",
        content.substring(content.length - 500)
      )
      console.log("🤖 RAW AI Response total length:", content.length)

      try {
        // Clean content: remove markdown code blocks and extra formatting
        let cleanContent = content.trim()

        // Remove markdown code block markers
        cleanContent = cleanContent.replace(/```json\s*/g, "")
        cleanContent = cleanContent.replace(/```\s*/g, "")

        // Remove bullet points that might interfere with JSON
        cleanContent = cleanContent.replace(/^[\s]*[•*-]\s*/gm, "")

        // Try to extract JSON if it's embedded in text
        const jsonMatch = cleanContent.match(/\{[\s\S]*\}/)
        if (jsonMatch) {
          cleanContent = jsonMatch[0]
        }

        console.log("🔍 Cleaned content for JSON parsing:", cleanContent)

        // Try to parse as JSON (expecting complete response without truncation)
        const parsed = JSON.parse(cleanContent)

        console.log("🔍 === PARSED JSON CONTENT ANALYSIS ===")
        console.log("📊 Parsed Object Keys:", Object.keys(parsed))

        // 🎯 PURE DYNAMIC CONTENT - Use AI's structure exactly as returned
        // No mapping, no forcing into predefined fields - just use what the AI gave us

        const result = {
          // Store the original data structure completely unchanged
          _rawData: parsed,
          _dynamicSections: [],
        }

        // Extract sections dynamically from whatever the AI returned
        Object.keys(parsed).forEach(key => {
          const value = parsed[key]
          if (Array.isArray(value) && value.length > 0) {
            // Create a dynamic section with the AI's original field name as title
            const sectionTitle = this.formatFieldNameAsTitle(key)
            result._dynamicSections.push({
              originalKey: key,
              title: sectionTitle,
              content: value,
              emoji: this.getEmojiForField(key),
            })
            console.log(
              `📋 Dynamic section created: "${sectionTitle}" with ${value.length} items`
            )
          }
        })

        console.log("🔍 === PURE DYNAMIC RESULTS ===")
        console.log(
          "📊 Total Dynamic Sections:",
          result._dynamicSections.length
        )
        console.log(
          "📊 Section Titles:",
          result._dynamicSections.map(s => s.title)
        )
        console.log("📊 Original Data Preserved:", Object.keys(result._rawData))

        // 🔄 BACKWARD COMPATIBILITY - Handle old cached summaries
        if (result._dynamicSections.length === 0) {
          console.log(
            "📋 No dynamic sections found, checking for legacy structure..."
          )

          // Check if this is an old-format summary with keyPoints, clinicalPearls, etc.
          const legacyFields = [
            "keyPoints",
            "clinicalPearls",
            "differentials",
            "imagingApproach",
            "diagnosticApproach",
            "focusAreas",
          ]
          legacyFields.forEach(field => {
            if (
              parsed[field] &&
              Array.isArray(parsed[field]) &&
              parsed[field].length > 0
            ) {
              const sectionTitle = this.formatFieldNameAsTitle(field)
              result._dynamicSections.push({
                originalKey: field,
                title: sectionTitle,
                content: parsed[field],
                emoji: this.getEmojiForField(field),
              })
              console.log(
                `📋 Converted legacy field '${field}' to dynamic section: "${sectionTitle}"`
              )
            }
          })
        }

        console.log("🔍 === END PURE DYNAMIC PARSING ===")

        return result
      } catch (e) {
        console.warn("🔍 JSON parsing failed, using enhanced fallback:", e)

        // Enhanced fallback: try to extract content from partial JSON or structured text
        const keyPoints = []
        const clinicalPearls = []
        const differentials = []

        // Try to extract arrays from partial JSON using regex
        const keyPointsMatch = content.match(/"keyPoints":\s*\[([\s\S]*?)\]/)
        const pearlsMatch = content.match(/"clinicalPearls":\s*\[([\s\S]*?)\]/)
        const differentialsMatch = content.match(
          /"differentials":\s*\[([\s\S]*?)\]/
        )

        if (keyPointsMatch) {
          console.log("🔧 Found keyPoints in partial JSON")
          const keyPointsText = keyPointsMatch[1]
          const points = keyPointsText.match(/"([^"]+)"/g) || []
          keyPoints.push(...points.map(p => p.replace(/"/g, "")))
        }

        if (pearlsMatch) {
          console.log("🔧 Found clinicalPearls in partial JSON")
          const pearlsText = pearlsMatch[1]
          const pearls = pearlsText.match(/"([^"]+)"/g) || []
          clinicalPearls.push(...pearls.map(p => p.replace(/"/g, "")))
        }

        if (differentialsMatch) {
          console.log("🔧 Found differentials in partial JSON")
          const diffsText = differentialsMatch[1]
          const diffs = diffsText.match(/"([^"]+)"/g) || []
          differentials.push(...diffs.map(p => p.replace(/"/g, "")))
        }

        // If regex extraction didn't work, fall back to line-by-line parsing
        if (
          keyPoints.length === 0 &&
          clinicalPearls.length === 0 &&
          differentials.length === 0
        ) {
          console.log("🔧 Using line-by-line fallback parsing")
          const lines = content.split("\n").filter(line => line.trim())
          let currentSection = "key"

          for (const line of lines) {
            const cleanLine = line
              .replace(/^[-•*]\s*/, "")
              .replace(/^"/, "")
              .replace(/",$/, "")
              .replace(/^\s*[\[\]{}",]\s*/, "") // Remove JSON artifacts
              .trim()

            // Section detection
            if (
              cleanLine.toLowerCase().includes("clinical") ||
              cleanLine.toLowerCase().includes("pearl")
            ) {
              currentSection = "pearls"
              continue
            }
            if (
              cleanLine.toLowerCase().includes("differential") ||
              cleanLine.toLowerCase().includes("diagnos")
            ) {
              currentSection = "diff"
              continue
            }

            // Content extraction
            if (
              cleanLine &&
              !cleanLine.includes("{") &&
              !cleanLine.includes("}") &&
              cleanLine.length > 10 &&
              !cleanLine.includes("keyPoints") &&
              !cleanLine.includes("clinicalPearls")
            ) {
              if (currentSection === "key") {
                keyPoints.push(cleanLine)
              } else if (currentSection === "pearls") {
                clinicalPearls.push(cleanLine)
              } else if (currentSection === "diff") {
                differentials.push(cleanLine)
              }
            }
          }
        }

        console.log("🔧 Fallback extraction results:", {
          keyPoints: keyPoints.length,
          clinicalPearls: clinicalPearls.length,
          differentials: differentials.length,
        })

        return {
          keyPoints: keyPoints.slice(0, 6),
          clinicalPearls: clinicalPearls.slice(0, 4),
          differentials: differentials.slice(0, 4),
          focusAreas: ["general"],
        }
      }
    }

    // 🔄 UNIFIED AI RESPONSE STORAGE
    async storeAIResponse(pageUrl, type, request, response, metadata) {
      try {
        const pageHash = this.getContentHash(pageUrl)
        const requestHash = this.getContentHash(JSON.stringify(request))
        const responseKey = `ai_response_${pageHash}_${type}_${requestHash}`

        const responseData = {
          type, // 'summary', 'qa', 'quiz'
          timestamp: Date.now(),
          pageUrl,
          pageTitle: document.title || "Unknown Page",
          request,
          response,
          metadata,
        }

        await GM.setValue(responseKey, JSON.stringify(responseData))
        console.log(`🔄 Unified AI response stored: ${type} for ${pageUrl}`)

        return responseKey
      } catch (error) {
        console.error("Error storing AI response:", error)
      }
    }

    // 🔄 UNIFIED AI RESPONSE RETRIEVAL
    async getPageAIResponses(pageUrl, type = null) {
      try {
        const pageHash = this.getContentHash(pageUrl)
        const allKeys = await GM.listValues()
        const pageKeys = allKeys.filter(
          key =>
            key.startsWith(`ai_response_${pageHash}`) &&
            (type ? key.includes(`_${type}_`) : true)
        )

        const responses = []
        for (const key of pageKeys) {
          const data = await GM.getValue(key)
          if (data) {
            responses.push(JSON.parse(data))
          }
        }

        // Sort by timestamp, most recent first
        return responses.sort((a, b) => b.timestamp - a.timestamp)
      } catch (error) {
        console.error("Error retrieving page AI responses:", error)
        return []
      }
    }

    // 💰 SIMPLIFIED TOKEN LOGGING (No Daily/Total Aggregation)
    async logTokenUsage(type, pageUrl, model, tokens, cost, requestId = null) {
      try {
        const timestamp = Date.now()
        const logKey = `token_log_${timestamp}`

        const logEntry = {
          timestamp,
          model,
          type, // 'summary', 'qa', 'quiz'
          pageUrl,
          tokens,
          cost,
          requestId, // Optional link to AI response
        }

        await GM.setValue(logKey, JSON.stringify(logEntry))
        console.log(
          `💰 Token usage logged: ${tokens.total} tokens, $${cost.toFixed(6)}`
        )

        return logKey
      } catch (error) {
        console.error("Error logging token usage:", error)
      }
    }

    // 💰 GET TOKEN USAGE LOGS (Raw data for UI formatting)
    async getTokenUsageLogs(startDate = null, endDate = null) {
      try {
        const allKeys = await GM.listValues()
        const logKeys = allKeys.filter(key => key.startsWith("token_log_"))

        const logs = []
        for (const key of logKeys) {
          const data = await GM.getValue(key)
          if (data) {
            const log = JSON.parse(data)

            // Filter by date range if provided
            if (startDate && log.timestamp < startDate) continue
            if (endDate && log.timestamp > endDate) continue

            logs.push(log)
          }
        }

        // Sort by timestamp, most recent first
        return logs.sort((a, b) => b.timestamp - a.timestamp)
      } catch (error) {
        console.error("Error getting token usage logs:", error)
        return []
      }
    }

    getContentHash(content) {
      // Simple hash function for content
      let hash = 0
      for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i)
        hash = (hash << 5) - hash + char
        hash = hash & hash // Convert to 32-bit integer
      }
      return Math.abs(hash).toString(36)
    }

    // Format markdown text for HTML display
    formatMarkdownToHTML(text) {
      let formatted = text
        // First, handle code blocks (triple backticks)
        .replace(
          /```([\s\S]*?)```/g,
          '<div style="background: #1a3a6b; padding: 12px; border-radius: 6px; margin: 10px 0; font-family: monospace; font-size: 12px; border-left: 4px solid #7198f8; overflow-x: auto;"><code>$1</code></div>'
        )

        // Handle inline code (single backticks)
        .replace(
          /`([^`]+)`/g,
          '<code style="background: #1a3a6b; padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 11px;">$1</code>'
        )

        // Handle tables (simple markdown table format)
        .replace(/\|(.+)\|/g, (match, content) => {
          // Split by pipes and create table cells
          const cells = content
            .split("|")
            .map(cell => cell.trim())
            .filter(cell => cell)
          return `<div style="display: flex; border-bottom: 1px solid #2c4a7c; padding: 4px 0;">${cells
            .map(
              cell =>
                `<div style="flex: 1; padding: 4px 8px; font-size: 12px;">${cell}</div>`
            )
            .join("")}</div>`
        })

        // Convert **bold** to <strong>
        .replace(
          /\*\*(.*?)\*\*/g,
          '<strong style="color: #7198f8;">$1</strong>'
        )

        // Convert *italic* to <em>
        .replace(/\*(.*?)\*/g, '<em style="color: #95a5a6;">$1</em>')

        // Handle headers (### format)
        .replace(
          /^###\s+(.*$)/gm,
          '<div style="margin: 16px 0 8px 0; font-size: 14px; font-weight: bold; color: #7198f8; border-bottom: 1px solid #2c4a7c; padding-bottom: 4px;">$1</div>'
        )
        .replace(
          /^##\s+(.*$)/gm,
          '<div style="margin: 18px 0 10px 0; font-size: 15px; font-weight: bold; color: #7198f8; border-bottom: 2px solid #2c4a7c; padding-bottom: 6px;">$1</div>'
        )
        .replace(
          /^#\s+(.*$)/gm,
          '<div style="margin: 20px 0 12px 0; font-size: 16px; font-weight: bold; color: #7198f8; border-bottom: 2px solid #7198f8; padding-bottom: 8px;">$1</div>'
        )

        // Convert numbered lists with proper indentation
        .replace(
          /^\d+\.\s+(.*$)/gm,
          '<div style="margin: 6px 0; padding-left: 12px; position: relative;"><span style="position: absolute; left: 0; color: #7198f8; font-weight: bold;">•</span>$1</div>'
        )

        // Convert bullet points with proper spacing
        .replace(
          /^[-•*]\s+(.*$)/gm,
          '<div style="margin: 6px 0; padding-left: 12px; position: relative;"><span style="position: absolute; left: 0; color: #7198f8; font-weight: bold;">•</span>$1</div>'
        )

        // Convert section headers (bold text followed by colon)
        .replace(
          /^\*\*(.*?):\*\*/gm,
          '<div style="margin: 12px 0 6px 0; font-weight: bold; color: #7198f8; font-size: 13px;">$1:</div>'
        )

        // Handle horizontal rules
        .replace(
          /^---+$/gm,
          '<hr style="border: none; border-top: 1px solid #2c4a7c; margin: 15px 0;">'
        )

        // Handle blockquotes
        .replace(
          /^>\s+(.*$)/gm,
          '<div style="border-left: 4px solid #7198f8; padding-left: 12px; margin: 8px 0; color: #95a5a6; font-style: italic;">$1</div>'
        )

        // Convert paragraph breaks (double newlines)
        .replace(/\n\n/g, '<div style="margin: 12px 0;"></div>')

        // Convert single line breaks
        .replace(/\n/g, "<br>")

      return formatted
    }

    // Format timestamp to human-readable "time ago" format
    formatTimeAgo(timestamp) {
      const now = Date.now()
      const diff = now - timestamp
      const minutes = Math.floor(diff / (1000 * 60))
      const hours = Math.floor(diff / (1000 * 60 * 60))
      const days = Math.floor(diff / (1000 * 60 * 60 * 24))

      if (days > 0) {
        return `${days} day${days > 1 ? "s" : ""} ago`
      } else if (hours > 0) {
        return `${hours} hour${hours > 1 ? "s" : ""} ago`
      } else if (minutes > 0) {
        return `${minutes} min${minutes > 1 ? "s" : ""} ago`
      } else {
        return "Just now"
      }
    }

    // View cached content in a beautiful modal
    async viewCacheContent(cacheKey, type) {
      try {
        // The cacheKey comes from the display, which has already removed ai_cache_ prefix
        // So we need to add it back when looking up in GM storage
        const fullCacheKey = cacheKey.startsWith("ai_cache_")
          ? cacheKey
          : `ai_cache_${cacheKey}`

        console.log("🔍 ViewCacheContent: Looking for cache key:", fullCacheKey)

        const cached = await GM.getValue(fullCacheKey, null)
        if (!cached) {
          alert("Cache content not found!")
          return
        }

        const parsedCache = JSON.parse(cached)
        const content = parsedCache.content
        const timestamp = new Date(parsedCache.timestamp)
          .toLocaleString("en-GB", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
          .replace(",", "")

        let formattedContent = ""

        if (type === "Summary") {
          // Format summary content beautifully
          formattedContent = `
            <div style="margin-bottom: 15px; padding: 10px; background: #0a1f3d; border-radius: 6px;">
              <div style="color: #7198f8; font-weight: bold; margin-bottom: 8px;">📄 Page Analysis</div>
              <div style="color: #b0bec5; font-size: 12px;">
                <strong>Difficulty:</strong> ${content.difficulty || "N/A"}<br>
                <strong>Reading Time:</strong> ${
                  content.readingTime || "N/A"
                } min
              </div>
            </div>
          `

          if (content.keyPoints && content.keyPoints.length > 0) {
            formattedContent += `
              <div style="margin-bottom: 15px; padding: 10px; background: #0a1f3d; border-radius: 6px;">
                <div style="color: #7198f8; font-weight: bold; margin-bottom: 8px;">🎯 Key Learning Points</div>
                ${content.keyPoints
                  .map(
                    point =>
                      `<div style="margin: 4px 0;">• ${this.formatMarkdownToHTML(
                        point
                      )}</div>`
                  )
                  .join("")}
              </div>
            `
          }

          if (content.clinicalPearls && content.clinicalPearls.length > 0) {
            formattedContent += `
              <div style="margin-bottom: 15px; padding: 10px; background: #0a1f3d; border-radius: 6px;">
                <div style="color: #7198f8; font-weight: bold; margin-bottom: 8px;">💎 Clinical Pearls</div>
                ${content.clinicalPearls
                  .map(
                    pearl =>
                      `<div style="margin: 4px 0;">• ${this.formatMarkdownToHTML(
                        pearl
                      )}</div>`
                  )
                  .join("")}
              </div>
            `
          }

          if (content.differentials && content.differentials.length > 0) {
            formattedContent += `
              <div style="margin-bottom: 15px; padding: 10px; background: #0a1f3d; border-radius: 6px;">
                <div style="color: #7198f8; font-weight: bold; margin-bottom: 8px;">🔍 Differentials</div>
                ${content.differentials
                  .map(
                    diff =>
                      `<div style="margin: 4px 0;">• ${this.formatMarkdownToHTML(
                        diff
                      )}</div>`
                  )
                  .join("")}
              </div>
            `
          }
        } else if (type === "Q&A") {
          // Q&A cache should contain formatted answer strings
          formattedContent = `
            <div style="margin-bottom: 15px; padding: 10px; background: #0f2142; border-radius: 6px;">
              <div style="color: #7198f8; font-weight: bold; margin-bottom: 8px;">💡 Answer</div>
              <div style="color: #e8eaed; line-height: 1.5;">${content}</div>
            </div>
          `
        }

        window.raTutor.uiManager.showDataModal(
          `🤖 ${type} Cache Content`,
          `
          <div style="margin-bottom: 15px; padding: 8px; background: #2c4a7c; border-radius: 4px; text-align: center;">
            <div style="color: #7f8c8d; font-size: 11px;">Generated: ${timestamp}</div>
            <div style="color: #7f8c8d; font-size: 11px;">Age: ${this.formatTimeAgo(
              parsedCache.timestamp
            )}</div>
          </div>
          ${formattedContent}
        `
        )
      } catch (error) {
        console.error("Error viewing cache content:", error)
        alert(`Error loading cache content: ${error.message}`)
      }
    }

    async answerQuestion(question, content, languageInstruction = "") {
      // Check unified storage first
      const pageUrl = window.location.pathname
      const existingResponses = await this.getPageAIResponses(pageUrl, "qa")

      // Look for existing answer to same question
      const cached = existingResponses.find(
        r =>
          r.request.question === question &&
          r.request.languageInstruction === languageInstruction
      )

      if (cached) {
        console.log("✅ Using cached unified Q&A (no API call needed)", {
          pageUrl,
          age: this.formatTimeAgo(cached.timestamp),
        })
        return cached.response.parsed
      }

      if (!this.apiKey) {
        return "❌ AI-powered Q&A requires an API key. Please configure your Mistral API key in the settings."
      }

      try {
        console.log("🚀 Generating fresh AI answer via Mistral")

        const prompt = `You are a radiology education expert. Answer the following question based on the provided content.

CONTENT: "${content.substring(0, 40000)}"

QUESTION: "${question}"

INSTRUCTIONS:
- Provide a clear, educational answer based on the content
- If the question cannot be answered from the content, say so
- Use medical terminology appropriately for learning
- Keep the answer concise but informative
- Focus on radiology and medical education aspects${languageInstruction}

ANSWER:`

        const response = await this.callMistralAPI(prompt, null, {
          type: "qa",
          pageUrl,
          question: question.substring(0, 100), // Truncate for logging
        })

        if (response && response.content) {
          const rawAnswer = response.content.trim()
          const formattedAnswer = this.formatMarkdownToHTML(rawAnswer)

          // � UNIFIED STORAGE ONLY: Store as AI response
          const responseKey = await this.storeAIResponse(
            pageUrl,
            "qa",
            {
              question,
              content: content.substring(0, 1000),
              languageInstruction,
            },
            { raw: rawAnswer, parsed: formattedAnswer },
            { model: this.model, questionLength: question.length }
          )

          console.log("✅ Q&A generated and stored in unified system", {
            pageUrl,
            responseKey: responseKey?.substring(0, 50) + "...",
          })

          return formattedAnswer
        } else {
          throw new Error("Invalid response from Mistral AI")
        }
      } catch (error) {
        console.error("❌ Error generating AI answer:", error)
        return "❌ Error generating answer. Please try again or check your API key."
      }
    }

    // Track API call using GM storage only
    async trackApiCallGM() {
      try {
        const dataManager = window.raTutor ? window.raTutor.dataManager : null
        if (!dataManager) return

        const statsKey = `api_stats_${this.getContentHash(
          window.location.pathname
        )}`
        let stats = await dataManager.loadData(statsKey, {
          apiCallsTotal: 0,
          lastApiCall: null,
        })

        stats.apiCallsTotal = (stats.apiCallsTotal || 0) + 1
        stats.lastApiCall = Date.now()
        await dataManager.saveData(statsKey, stats)
        console.log(
          `API call tracked (GM storage). Total: ${stats.apiCallsTotal}`
        )
      } catch (error) {
        console.error("Error tracking API call (GM storage):", error)
      }
    }

    // GDPR: Sanitize content to remove any potential personal information
    sanitizeContent(content) {
      // Remove email addresses, phone numbers, and other PII patterns
      return content
        .replace(
          /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
          "[EMAIL]"
        )
        .replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, "[PHONE]")
        .replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, "[CARD]")
        .replace(/\b[A-Z][a-z]+ [A-Z][a-z]+\b/g, "[NAME]") // Simple name pattern
    }

    // GDPR: Validate quiz data contains no personal information
    validateQuizData(quizData) {
      const sensitivePatterns = [
        /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/, // emails
        /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/, // phone numbers
        /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/, // card numbers
      ]

      const checkText = JSON.stringify(quizData)
      for (const pattern of sensitivePatterns) {
        if (pattern.test(checkText)) {
          console.warn("🔒 GDPR: Personal data detected in quiz content")
          throw new Error(
            "Generated content contains sensitive data. Please try again."
          )
        }
      }

      return quizData
    }

    // Unified API call method with tracking
    async callMistralAPI(prompt, model = null, context = {}) {
      if (!this.apiKey) {
        throw new Error("API key required for Mistral AI calls")
      }

      try {
        const response = await GM.xmlHttpRequest({
          method: "POST",
          url: `${this.baseURL}/chat/completions`,
          headers: {
            Authorization: `Bearer ${this.apiKey}`,
            "Content-Type": "application/json",
          },
          data: JSON.stringify({
            model: model || this.model,
            messages: [
              {
                role: "user",
                content: prompt,
              },
            ],
            // No max_tokens limit - let the model complete naturally
            // With our comprehensive caching system, we want complete responses
            //temperature: 0.7,
          }),
        })

        // Track API call for transparency (GM storage only)
        await this.trackApiCallGM()

        const data = JSON.parse(response.responseText)

        // 🔍 DETAILED API RESPONSE LOGGING FOR ANALYSIS
        console.log("🚀 === COMPLETE MISTRAL API RESPONSE ANALYSIS ===")
        console.log("📊 Full Response Status:", response.status)
        console.log("📊 Response Headers:", response.responseHeaders)
        console.log(
          "📊 Raw Response Text Length:",
          response.responseText.length
        )
        console.log(
          "📊 Raw Response Text (first 2000 chars):",
          response.responseText.substring(0, 2000)
        )
        console.log(
          "📊 Raw Response Text (last 1000 chars):",
          response.responseText.substring(response.responseText.length - 1000)
        )

        console.log("🔍 === PARSED JSON DATA STRUCTURE ===")
        console.log("📊 Complete Data Object:", data)
        console.log("📊 Data Keys:", Object.keys(data))

        if (data.choices && data.choices.length > 0) {
          console.log("📊 Choices Array Length:", data.choices.length)
          console.log("📊 First Choice Object:", data.choices[0])
          console.log("📊 First Choice Keys:", Object.keys(data.choices[0]))

          if (data.choices[0].message) {
            console.log("📊 Message Object:", data.choices[0].message)
            console.log(
              "📊 Message Keys:",
              Object.keys(data.choices[0].message)
            )
            console.log(
              "📊 Message Content Length:",
              data.choices[0].message.content?.length
            )
            console.log(
              "📊 Message Content (first 1500 chars):",
              data.choices[0].message.content?.substring(0, 1500)
            )
            console.log(
              "📊 Message Content (last 800 chars):",
              data.choices[0].message.content?.substring(
                data.choices[0].message.content.length - 800
              )
            )
          }
        }

        if (data.usage) {
          console.log("📊 API Usage Stats:", data.usage)
        }

        console.log("🔍 === END API RESPONSE ANALYSIS ===")

        // 💰 DYNAMIC TOKEN COST CALCULATION
        if (data.usage) {
          const cost = await this.calculateCost(
            model || this.model,
            data.usage.prompt_tokens || 0,
            data.usage.completion_tokens || 0
          )

          await this.logTokenUsage(
            context.type || "unknown",
            context.pageUrl || window.location.pathname,
            model || this.model,
            {
              prompt: data.usage.prompt_tokens || 0,
              completion: data.usage.completion_tokens || 0,
              total: data.usage.total_tokens || 0,
            },
            cost,
            context.requestId || null
          )
        }

        return {
          content: data.choices[0].message.content,
        }
      } catch (error) {
        console.error("🔒 GDPR: Mistral API call failed:", error)
        throw error
      }
    }

    // 💰 GET TOKEN USAGE STATISTICS (now from simplified logs)
    async getTokenUsageStats() {
      try {
        const logs = await this.getTokenUsageLogs()
        if (!logs.length) return null

        // UI can format these logs as needed - daily summaries, totals, etc.
        const totalTokens = logs.reduce((sum, log) => sum + log.tokens.total, 0)
        const totalCost = logs.reduce((sum, log) => sum + log.cost, 0)
        const totalCalls = logs.length

        return {
          totalTokens,
          totalCost,
          totalApiCalls: totalCalls,
          firstCall: logs[logs.length - 1]?.timestamp,
          lastCall: logs[0]?.timestamp,
          rawLogs: logs, // Raw data for detailed analysis
        }
      } catch (error) {
        console.error("Error getting token usage stats:", error)
        return null
      }
    }

    // 🏷️ HELPER METHODS FOR DYNAMIC CONTENT PARSING
    formatFieldNameAsTitle(fieldName) {
      // Convert camelCase or snake_case field names to readable titles
      return fieldName
        .replace(/([A-Z])/g, " $1") // Add space before capitals
        .replace(/_/g, " ") // Replace underscores with spaces
        .split(" ")
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(" ")
        .trim()
    }

    getEmojiForField(fieldName) {
      // Map field names to appropriate emojis for better UX
      const emojiMap = {
        keyPoints: "🎯",
        clinicalPearls: "💎",
        differentials: "🔍",
        imagingPearls: "📸",
        technicalTips: "⚙️",
        clinicalPoints: "🏥",
        diagnosticApproach: "🩺",
        keyTakeaways: "📝",
        imagingApproach: "📋",
        keyDistinguishers: "🔬",
        focusAreas: "🎓",
        treatmentApproach: "💊",
        pathologyFindings: "🔬",
      }

      return emojiMap[fieldName] || "📌" // Default emoji if not found
    }

    // 🔍 CONSOLE-ACCESSIBLE DATA ANALYSIS TOOL
    async createConsoleDataAnalyzer() {
      const analyzer = {
        // Analyze all token logs
        async analyzeTokenLogs() {
          console.log("🔍 === TOKEN LOGS ANALYSIS ===")
          try {
            const allKeys = await GM.listValues()
            const tokenKeys = allKeys.filter(key =>
              key.startsWith("token_log_")
            )

            if (tokenKeys.length === 0) {
              console.log("📊 No token logs found")
              return
            }

            console.log(`📊 Found ${tokenKeys.length} token log entries`)

            let totalTokens = 0
            let totalCost = 0
            const logsByType = {}
            const logsByModel = {}

            for (const key of tokenKeys.slice(0, 20)) {
              // Limit to recent 20 for performance
              try {
                const data = await GM.getValue(key)
                if (data) {
                  const log = JSON.parse(data)
                  totalTokens += log.tokens.total || 0
                  totalCost += log.cost || 0

                  logsByType[log.type] = (logsByType[log.type] || 0) + 1
                  logsByModel[log.model] = (logsByModel[log.model] || 0) + 1

                  console.log(
                    `📋 Log: ${new Date(log.timestamp).toLocaleString()} | ${
                      log.type
                    } | ${log.tokens.total} tokens | $${log.cost.toFixed(6)}`
                  )
                }
              } catch (e) {
                console.warn(`⚠️ Error parsing log ${key}:`, e)
              }
            }

            console.log(`💰 Total Cost: $${totalCost.toFixed(6)}`)
            console.log(`🔢 Total Tokens: ${totalTokens.toLocaleString()}`)
            console.log(`📊 Usage by Type:`, logsByType)
            console.log(`🤖 Usage by Model:`, logsByModel)
          } catch (error) {
            console.error("❌ Error analyzing token logs:", error)
          }
        },

        // Analyze unified AI responses
        async analyzeUnifiedResponses() {
          console.log("🔍 === UNIFIED AI RESPONSES ANALYSIS ===")
          try {
            const allKeys = await GM.listValues()
            const responseKeys = allKeys.filter(key =>
              key.startsWith("ai_response_")
            )

            if (responseKeys.length === 0) {
              console.log("📊 No unified AI responses found")
              return
            }

            console.log(`📊 Found ${responseKeys.length} unified AI responses`)

            let totalSize = 0
            const responsesByType = {}

            for (const key of responseKeys.slice(0, 20)) {
              // Show more since this is the main system now
              try {
                const data = await GM.getValue(key)
                if (data) {
                  const response = JSON.parse(data)
                  const size = JSON.stringify(response).length
                  totalSize += size

                  responsesByType[response.type] =
                    (responsesByType[response.type] || 0) + 1

                  const age = Math.floor(
                    (Date.now() - response.timestamp) / (1000 * 60 * 60)
                  ) // hours
                  console.log(
                    `📋 Response: ${response.type} | ${(size / 1024).toFixed(
                      1
                    )}KB | ${age}h old | ${response.pageTitle || "Unknown"}`
                  )
                }
              } catch (e) {
                console.warn(`⚠️ Error parsing response ${key}:`, e)
              }
            }

            console.log(
              `💾 Total Responses Size: ${(totalSize / 1024).toFixed(1)}KB`
            )
            console.log(`📊 Responses by Type:`, responsesByType)
          } catch (error) {
            console.error("❌ Error analyzing unified responses:", error)
          }
        },

        // Full storage overview
        async fullStorageAnalysis() {
          console.log("🔍 === UNIFIED STORAGE SYSTEM ANALYSIS ===")
          try {
            const allKeys = await GM.listValues()
            console.log(`📊 Total Storage Keys: ${allKeys.length}`)

            const categories = {}
            let totalEstimatedSize = 0

            // Categorize all keys (unified system only)
            for (const key of allKeys) {
              let category = "Other"
              if (key.startsWith("token_log_")) category = "Token Logs"
              else if (key.startsWith("ai_response_")) category = "AI Responses"
              else if (key.startsWith("ra_tutor_gdpr_"))
                category = "User Settings"
              else if (key.includes("api_stats_")) category = "API Stats"
              // Note: No more ai_cache_ or qa_history_ - pure unified system!

              categories[category] = (categories[category] || 0) + 1

              // Estimate size for first few keys in each category
              if (categories[category] <= 5) {
                try {
                  const data = await GM.getValue(key)
                  if (data) {
                    const size =
                      typeof data === "string"
                        ? data.length
                        : JSON.stringify(data).length
                    totalEstimatedSize += size
                  }
                } catch (e) {
                  console.warn(`⚠️ Error reading ${key}:`, e)
                }
              }
            }

            console.log("📊 Storage Categories (Unified System):", categories)
            console.log(
              `💾 Estimated Size (sample): ${(
                totalEstimatedSize / 1024
              ).toFixed(1)}KB`
            )

            // Run individual analyses (only token logs and unified responses now)
            await this.analyzeTokenLogs()
            await this.analyzeUnifiedResponses()
          } catch (error) {
            console.error("❌ Error in unified storage analysis:", error)
          }
        },

        // Cleanup suggestions
        async cleanupSuggestions() {
          console.log("🔍 === CLEANUP SUGGESTIONS ===")
          try {
            const allKeys = await GM.listValues()
            const now = Date.now()
            const oneWeekAgo = now - 7 * 24 * 60 * 60 * 1000

            let oldCacheCount = 0
            let oldLogsCount = 0

            for (const key of allKeys) {
              try {
                if (key.startsWith("ai_cache_")) {
                  const data = await GM.getValue(key)
                  if (data) {
                    const cache = JSON.parse(data)
                    if (cache.timestamp && cache.timestamp < oneWeekAgo) {
                      oldCacheCount++
                    }
                  }
                }

                if (key.startsWith("token_log_")) {
                  const timestamp = parseInt(key.split("_")[2])
                  if (timestamp < oneWeekAgo) {
                    oldLogsCount++
                  }
                }
              } catch (e) {
                console.warn(`⚠️ Error checking ${key}:`, e)
              }
            }

            console.log(`📊 Old cache entries (>1 week): ${oldCacheCount}`)
            console.log(`📊 Old log entries (>1 week): ${oldLogsCount}`)

            if (oldCacheCount > 0 || oldLogsCount > 0) {
              console.log(
                "💡 Cleanup suggestion: Consider clearing old entries to free space"
              )
              console.log(
                "🔧 Use: window.raTutor.dataManager.clearAllUserData() to reset all data"
              )
            } else {
              console.log("✅ Storage is clean, no cleanup needed")
            }
          } catch (error) {
            console.error("❌ Error generating cleanup suggestions:", error)
          }
        },
      }

      return analyzer
    }

    // Get Q&A history for a specific page from unified storage
    async getQAHistory(pageUrl) {
      try {
        const responses = await this.getPageAIResponses(pageUrl, "qa")

        // Convert to the expected format for backward compatibility
        return responses
          .map(response => ({
            question: response.request.question,
            answer: response.response.parsed || response.response.raw,
            timestamp: response.timestamp,
          }))
          .reverse() // Most recent first
      } catch (error) {
        console.error("Error getting Q&A history:", error)
        return []
      }
    }

    // ========================================
    // 💰 PRICING MANAGEMENT METHODS
    // ========================================

    // Get current pricing for a model (from storage or config)
    async getCurrentPricing(model = null) {
      try {
        // Use provided model or fallback to current model
        const targetModel = model || this.model

        // Try to get user-updated pricing from storage first
        const customPricing = await GM.getValue("mistral_pricing", null)
        if (customPricing) {
          const pricing = JSON.parse(customPricing)
          if (pricing[targetModel]) {
            return pricing[targetModel]
          }
          if (pricing["default"]) {
            return pricing["default"]
          }
        }

        // Fallback to CONFIG pricing
        if (CONFIG.PRICING && CONFIG.PRICING[targetModel]) {
          return CONFIG.PRICING[targetModel]
        }

        // Final fallback to default config pricing
        return CONFIG.PRICING["default"] || { input: 0.003, output: 0.009 }
      } catch (error) {
        console.error("Error getting pricing:", error)
        // Return safe default
        return { input: 0.003, output: 0.009 }
      }
    }

    // Update pricing for a specific model
    async updateModelPricing(model, inputCost, outputCost) {
      try {
        // Get existing custom pricing or start fresh
        let customPricing = {}
        const existing = await GM.getValue("mistral_pricing", null)
        if (existing) {
          customPricing = JSON.parse(existing)
        }

        // Update the specific model pricing
        customPricing[model] = {
          input: parseFloat(inputCost),
          output: parseFloat(outputCost),
          lastUpdated: Date.now(),
        }

        // Save back to storage
        await GM.setValue("mistral_pricing", JSON.stringify(customPricing))
        console.log(
          `💰 Updated pricing for ${model}: input=$${inputCost}, output=$${outputCost}`
        )

        return true
      } catch (error) {
        console.error("Error updating pricing:", error)
        return false
      }
    }

    // Calculate cost for a specific API call
    async calculateCost(model, promptTokens, completionTokens) {
      try {
        const pricing = await this.getCurrentPricing(model)

        // Convert per-1K-token pricing to per-token
        const inputCostPerToken = pricing.input / 1000
        const outputCostPerToken = pricing.output / 1000

        const totalCost =
          promptTokens * inputCostPerToken +
          completionTokens * outputCostPerToken

        return totalCost
      } catch (error) {
        console.error("Error calculating cost:", error)
        // Fallback to old hardcoded calculation
        return promptTokens * 0.000003 + completionTokens * 0.000009
      }
    }

    // Get all available pricing information
    async getAllPricing() {
      try {
        // Get custom pricing from storage
        const customPricing = await GM.getValue("mistral_pricing", null)
        let custom = {}
        if (customPricing) {
          custom = JSON.parse(customPricing)
        }

        return {
          default: CONFIG.PRICING || {},
          custom: custom,
          effective: { ...CONFIG.PRICING, ...custom }, // Custom overrides default
        }
      } catch (error) {
        console.error("Error getting all pricing:", error)
        return {
          default: CONFIG.PRICING || {},
          custom: {},
          effective: CONFIG.PRICING || {},
        }
      }
    }
  }

  // ========================================
  // 🎨 UI MANAGER
  // ========================================
  class UIManager {
    constructor(aiTutor, dataManager) {
      this.aiTutor = aiTutor
      this.dataManager = dataManager
      this.isMinimized = CONFIG.TUTOR_PANEL_OPEN_BY_DEFAULT ? false : true
      this.currentTab = "summary" // Start with summary tab
      this.currentQuiz = null
      this.currentSummaryType = null // Track current summary type for regeneration
    }

    init() {
      this.injectStyles()
      this.createTutorPanel()
      this.createScrollProgressBar()

      // Set initial toggle button state
      const toggleButton = document.getElementById("ra-tutor-toggle")
      if (toggleButton) {
        toggleButton.style.display = this.isMinimized ? "block" : "none"
      }

      // Initialize summary content after a brief delay to ensure DOM is ready
      setTimeout(async () => {
        console.log("🔄 Initial updateSummaryTab() call from init()")
        await this.updateSummaryTab()
      }, 100)
    }

    injectStyles() {
      GM.addStyle(CSS_STYLES)
    }

    createScrollProgressBar() {
      // Remove existing scroll bar if it exists
      const existingScrollBar = document.getElementById("ra-scroll-progress")
      if (existingScrollBar) {
        existingScrollBar.remove()
      }

      // Get page content to calculate word count
      const pageContent = this.aiTutor.extractPageContent()
      const wordCount = pageContent ? pageContent.trim().split(/\s+/).length : 0
      const readingTime = Math.ceil(wordCount / 80) // 80 words per minute for learning, rough estimate

      // Create scroll progress container
      const scrollContainer = document.createElement("div")
      scrollContainer.id = "ra-scroll-progress"

      Object.assign(scrollContainer.style, {
        position: "fixed",
        top: "0",
        left: "0",
        right: "0",
        height: "25px",
        background: "linear-gradient(135deg, #123262, #1a3a6b)",
        border: "none",
        boxShadow: "0 2px 10px rgba(0, 0, 0, 0.3)",
        zIndex: "99997",
        display: "flex",
        alignItems: "center",
        fontFamily:
          "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
        fontSize: "11px",
        color: "#e8eaed",
      })

      // Create word count and reading time info (left side)
      const infoDiv = document.createElement("div")
      infoDiv.style.cssText = `
        padding: 0 12px;
        background: rgba(113, 152, 248, 0.1);
        border-radius: 0 15px 15px 0;
        font-weight: bold;
        min-width: 140px;
        text-align: center;
        border-right: 1px solid #7198f8;
      `

      // Set initial content
      infoDiv.innerHTML = `${wordCount.toLocaleString()} words • ${readingTime} min read • 0%`

      // Create progress bar container (center/right)
      const progressContainer = document.createElement("div")
      progressContainer.style.cssText = `
        flex: 1;
        margin: 0 12px;
        height: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        overflow: hidden;
      `

      // Create progress bar fill
      const progressFill = document.createElement("div")
      progressFill.id = "ra-scroll-fill"
      progressFill.style.cssText = `
        height: 100%;
        background: linear-gradient(90deg, #7198f8, #28a745);
        border-radius: 4px;
        width: 0%;
        transition: width 0.1s ease-out;
      `

      progressContainer.appendChild(progressFill)
      scrollContainer.appendChild(infoDiv)
      scrollContainer.appendChild(progressContainer)

      // Add to page
      document.body.appendChild(scrollContainer)

      // Add scroll listener to update progress
      let scrollPercent = 0
      const updateScrollProgress = () => {
        const scrollTop =
          window.pageYOffset || document.documentElement.scrollTop
        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight
        scrollPercent = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0

        progressFill.style.width = `${Math.min(
          100,
          Math.max(0, scrollPercent)
        )}%`

        const newContent = `${wordCount.toLocaleString()} words • ${readingTime} min read • ${Math.round(
          scrollPercent
        )}%`

        infoDiv.innerHTML = newContent
      }

      // Initial update and add listener
      updateScrollProgress()
      window.addEventListener("scroll", updateScrollProgress, { passive: true })

      // Adjust page content to account for the scroll bar - target specific page header
      const adjustPageContent = () => {
        // Add margin to body
        document.body.style.marginTop = "25px"

        // Target the specific navbar with the exact selector path
        const specificNavbar = document.querySelector(
          "body > nav.flex-wrap.px-4.fixed.w-full.z-20.top-0.bg-back, nav.flex-wrap.px-4.md\\:px-6.pt-2.fixed.w-full.z-20.top-0.bg-back"
        )
        if (specificNavbar) {
          // Move it down by our scroll bar height
          specificNavbar.style.top = "25px"
          console.log("📍 Adjusted specific navbar with top-0 class")
        }

        // Fallback more general selector in case the above doesn't work
        const fallbackNavbar = document.querySelector(
          'nav[class*="flex-wrap"][class*="fixed"][class*="top-0"]'
        )
        if (fallbackNavbar && fallbackNavbar !== specificNavbar) {
          fallbackNavbar.style.top = "25px"
          console.log("📍 Adjusted navbar via fallback selector")
        }

        // Adjust common content containers that might be positioned at top
        const selectors = [
          "#content",
          ".content",
          "main",
          ".main",
          "#main",
          "article",
          ".article",
        ]
        selectors.forEach(selector => {
          const element = document.querySelector(selector)
          if (element && !element.style.marginTop) {
            element.style.marginTop = "25px"
          }
        })

        // General fallback for any other fixed headers
        const headers = document.querySelectorAll("header, .header, #header")
        headers.forEach(header => {
          if (
            header.style.position === "fixed" ||
            getComputedStyle(header).position === "fixed"
          ) {
            header.style.top = "25px"
          }
        })
      }

      // Apply immediately and after a short delay to catch dynamic content
      adjustPageContent()
      setTimeout(adjustPageContent, 500)
    }

    createTutorPanel() {
      const panel = document.createElement("div")
      panel.id = "ra-tutor-panel"

      // Use direct style assignment
      Object.assign(panel.style, {
        position: "fixed",
        top: "25px", // Add top padding to accommodate scroll bar
        right: "0",
        width: "365px",
        height: "calc(100vh - 25px)", // Adjust height to account for top offset
        background: "linear-gradient(145deg, #123262, #387593ff)",
        boxShadow: "-5px 0 20px rgba(0, 0, 0, 0.3)",
        zIndex: "99999",
        fontFamily:
          "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
        transition: "transform 0.3s ease, box-shadow 0.3s ease",
        overflowY: "auto",
        color: "#e8eaed",
        display: "flex",
        flexDirection: "column",
        transform: this.isMinimized
          ? "translateX(calc(100% - 10px))"
          : "translateX(0)",
      })

      panel.innerHTML = `
                <div class="tutor-content" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                    <!-- Tab buttons temporarily disabled during development 
                    <div class="tab-buttons" style="flex-shrink: 0;">
                        <button class="tab-button active" data-action="tab" data-tab="summary">Summary</button>
                        <button class="tab-button" data-action="tab" data-tab="quiz">Quiz</button>
                    </div>
                    -->

                    <div id="summary-tab" class="tutor-tab active" style="flex: 1; overflow-y: auto; min-height: 0; padding: 5px;">
                        <div id="summary-content" style="width: 100%; min-height: 200px;">
                            <div style="text-align: center;">
                                <div style="color: #7198f8; font-size: 14px; font-weight: bold;">Loading AI Summary...</div>
                                <div style="color: #95a5a6; font-size: 11px; margin-top: 5px;">Analyzing page content</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Quiz tab temporarily disabled during development
                    <div id="quiz-tab" class="tutor-tab">
                        <div id="quiz-content">
                            <button data-action="generate-quiz" style="width: 100%; padding: 5px; background: linear-gradient(135deg, #7198f8 0%, #42a0d6ff 100%); color: white; border: none; border-radius: 8px; cursor: pointer;">
                                🧠 Test My Knowledge
                            </button>
                        </div>
                    </div>
                    -->
                </div>

                <!-- Settings Section -->
                <div class="tutor-settings" style="flex-shrink: 0; padding: 5px 5px; background: #38759300); font-size: 11px; border-top: 0px solid #2c4a7c;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">


                        <button id="toggle-settings" style="background: none; border: none; color: #7198f8; cursor: pointer; font-size: 14px; padding: 0; text-align: left; width: 100%;">
                            <strong>⚙️</strong>
                        </button>
                    </div>
                    <div id="settings-content" style="display: none; max-height: 200px; overflow-y: auto;">
                        <!-- Language Selection -->
                        <div style="margin-bottom: 12px; padding: 8px; background: #1a3a6b; border-radius: 6px;">
                            <div style="color: #b0bec5; margin-bottom: 6px;"><strong>🌐 AI Response Language</strong></div>
                            <select id="ai-language-select" style="width: 100%; padding: 6px; background: #0f2142; color: white; border: 1px solid #2c4a7c; border-radius: 4px; font-size: 11px;">
                                <option value="english">🇬🇧 English (Default)</option>
                                <option value="slovenian">🇸🇮 Slovensko</option>
                                <option value="croatian">🇭🇷 Hrvatski</option>
                                <option value="serbian">🇷🇸 Srpski</option>
                            </select>
                            <div style="font-size: 9px; color: #7f8c8d; margin-top: 4px;">AI will respond in the selected language regardless of question language</div>
                        </div>
                        
                        <!-- API Key Management -->
                        <div style="margin-bottom: 12px; padding: 8px; background: #1a3a6b; border-radius: 6px;">
                            <div style="color: #b0bec5; margin-bottom: 6px;"><strong>🔑 API Key Status</strong></div>
                            <div id="api-key-status" style="color: #95a5a6; font-size: 10px; margin-bottom: 6px;">Loading...</div>
                            <div style="display: flex; gap: 6px;">
                                <button data-action="manage-api-key" style="padding: 4px 8px; background: #7198f8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                                    Manage Key
                                </button>
                                <button data-action="test-api-key" style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                                    Test Key
                                </button>
                            </div>
                        </div>
                        
                        <!-- Pricing Management -->
                        <div style="margin-bottom: 12px; padding: 8px; background: #1a3a6b; border-radius: 6px;">
                            <div style="color: #b0bec5; margin-bottom: 6px;"><strong>💰 API Pricing Management</strong></div>
                            <div id="pricing-status" style="color: #95a5a6; font-size: 10px; margin-bottom: 6px;">Loading...</div>
                            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                                <button data-action="view-pricing" style="padding: 4px 8px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                                    📋 View Pricing
                                </button>
                                <button data-action="update-pricing" style="padding: 4px 8px; background: #ffc107; color: black; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                                    ✏️ Update Costs
                                </button>
                            </div>
                            <div style="font-size: 9px; color: #7f8c8d; margin-top: 4px;">Keep pricing current for accurate cost tracking</div>
                        </div>
                        
                        <!-- Data Management -->
                        <div style="margin-bottom: 12px; padding: 8px; background: #1a3a6b; border-radius: 6px;">
                            <div style="color: #b0bec5; margin-bottom: 8px;"><strong>💾 Data Management</strong></div>
                            
                            <!-- View/Export Section -->
                            <div style="margin-bottom: 8px; padding: 6px; background: #123262; border-radius: 4px;">
                                <button data-action="view-data-overview" style="padding: 4px 8px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; margin-right: 6px; margin-bottom: 4px;">
                                    📊 Review Data by Day
                                </button>
                                <button data-action="export-data" style="padding: 4px 8px; background: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                                    📤 Export Data
                                </button>
                            </div>
                            
                            <!-- Danger Zone -->
                            <div style="padding: 6px; background: #2c1810; border-radius: 4px; border: 1px solid #8b4513;">
                                <div style="color: #ff6b6b; font-size: 10px; margin-bottom: 4px;"><strong>⚠️ Danger Zone</strong></div>
                                <button data-action="purge-data-keep-key" style="padding: 4px 8px; background: #fd7e14; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; margin-right: 6px; margin-bottom: 4px;">
                                    🗑️ Purge Data (Keep API Key)
                                </button>
                                <button data-action="purge-all-data" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                                    💥 Purge Everything
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Attribution Footer - Fixed to bottom -->
                <div class="tutor-footer" style="flex-shrink: 0; padding: 9px 9px; border-top: 1px solid #2c4a7c; background: #0f2142; font-size: 10px; color: #95a5a6; text-align: center; line-height: 1.4;">
                    Made with ❤️ by 
                    <a href="https://www.simonrekanovic.com" target="_blank" style="color: #7198f8; text-decoration: none;">simonrekanovic.com</a> • find me on 
                    <a href="https://www.linkedin.com/in/simonrekanovic" target="_blank" style="color: #7198f8; text-decoration: none;">LinkedIn</a><br>
                    <span style="font-size: 8px; color: #7f8c8d;">The radiology assistant tutor v${
                      GM.info ? GM.info.script.version : "0.0.1"
                    }
                    <br><strong>CAUTION: AI may generate incorrect or misleading information. Always verify with reliable sources.</strong> </span>
                </div>
            `

      document.body.appendChild(panel)

      // Add event listeners to avoid timing issues with window.raTutor
      this.addPanelEventListeners(panel)

      // Create floating toggle button for when sidebar is hidden
      const toggleButton = document.createElement("button")
      toggleButton.id = "ra-tutor-toggle"
      toggleButton.innerHTML = "🧠"

      // Use direct style assignment for the toggle button
      Object.assign(toggleButton.style, {
        position: "fixed",
        right: "20px",
        top: "50%",
        transform: "translateY(-50%)",
        width: "50px",
        height: "50px",
        borderRadius: "50%",
        backgroundColor: "#7198f8",
        color: "white",
        border: "none",
        cursor: "pointer",
        fontSize: "20px",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.3)",
        zIndex: "99998",
        display: this.isMinimized ? "block" : "none",
        transition: "all 0.3s ease",
      })

      toggleButton.onclick = () => {
        if (window.raTutor && window.raTutor.ui) {
          window.raTutor.ui.togglePanel()
        } else {
          console.warn("🔒 GDPR: Tutor not fully initialized yet")
        }
      }

      // Add hover effects via event listeners
      toggleButton.addEventListener("mouseenter", () => {
        toggleButton.style.transform = "translateY(-50%) scale(1.1)"
        toggleButton.style.boxShadow = "0 6px 20px rgba(18, 50, 98, 0.6)"
      })

      toggleButton.addEventListener("mouseleave", () => {
        toggleButton.style.transform = "translateY(-50%)"
        toggleButton.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)"
      })

      toggleButton.title = "Open AI Tutor"
      document.body.appendChild(toggleButton)
    }

    addPanelEventListeners(panel) {
      // Tab buttons
      const tabButtons = panel.querySelectorAll('[data-action="tab"]')
      tabButtons.forEach(button => {
        button.addEventListener("click", () => {
          const tab = button.getAttribute("data-tab")
          this.switchTab(tab)
        })
      })

      // Generate quiz button
      // const generateQuizBtn = panel.querySelector(
      //   '[data-action="generate-quiz"]'
      // )
      // if (generateQuizBtn) {
      //   generateQuizBtn.addEventListener("click", () => this.generateQuiz())
      // }

      // Event delegation for dynamically created buttons
      panel.addEventListener("click", e => {
        if (e.target.dataset.action === "setup-api") {
          this.showApiKeySetup()
        } else if (e.target.dataset.action === "clear-data") {
          this.clearAllData()
        } else if (e.target.dataset.action === "manage-api-key") {
          this.showApiKeySetup()
        } else if (e.target.dataset.action === "test-api-key") {
          this.testApiKey()
        } else if (e.target.dataset.action === "view-pricing") {
          console.log("💰 View pricing clicked")
          this.showPricingOverview()
        } else if (e.target.dataset.action === "update-pricing") {
          console.log("✏️ Update pricing clicked")
          this.showPricingEditor()
        } else if (e.target.dataset.action === "view-data-overview") {
          console.log("� View data overview clicked")
          this.showDataOverview()
        } else if (e.target.dataset.action === "export-data") {
          console.log("📤 Export data clicked")
          this.exportAllData()
        } else if (e.target.dataset.action === "purge-data-keep-key") {
          console.log("🗑️ Purge data (keep key) clicked")
          this.purgeDataKeepKey()
        } else if (e.target.dataset.action === "purge-all-data") {
          console.log("💥 Purge all data clicked")
          this.purgeAllData()
        }
      })

      // Settings panel toggle
      const settingsHeader = panel.querySelector(".tutor-settings")
      if (settingsHeader) {
        const toggleSettings = settingsHeader.querySelector("#toggle-settings")
        if (toggleSettings) {
          toggleSettings.addEventListener("click", () => this.toggleSettings())
        }
      }

      // Language selection handler
      panel.addEventListener("change", e => {
        if (e.target.id === "ai-language-select") {
          this.saveLanguagePreference(e.target.value)
        }
      })

      // Initialize settings content
      this.updateSettingsContent()
    }

    async updateSummaryTab() {
      console.log("📋 updateSummaryTab() called")
      const content = document.getElementById("summary-content")
      if (!content) {
        console.log("📋 No summary-content element found")
        return
      }

      // Check if AI features are available
      const hasKey = this.aiTutor.hasApiKey()
      console.log("📋 API key available:", hasKey)

      if (!hasKey) {
        console.log("📋 No API key - showing setup UI")
        content.innerHTML = `
          <div style="text-align: center; padding: 30px;">
            <div style="font-size: 48px; margin-bottom: 20px;">🧠</div>
            <h3 style="color: #7198f8; margin-bottom: 15px;">AI-Powered Learning Assistant</h3>
            <p style="color: #b0bec5; line-height: 1.6; margin-bottom: 25px;">
              Get intelligent summaries, ask questions, and enhance your radiology learning with AI.
            </p>
            <button data-action="setup-api" style="padding: 12px 24px; background: linear-gradient(135deg, #7198f8, #28a745); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; box-shadow: 0 4px 12px rgba(113, 152, 248, 0.3);">
              🔧 Setup API Key to Begin
            </button>
            <div style="margin-top: 20px; padding: 15px; background: rgba(113, 152, 248, 0.1); border-radius: 8px; border-left: 4px solid #7198f8;">
              <div style="font-size: 12px; color: #95a5a6; line-height: 1.5;">
                <strong>📊 Page Stats:</strong> Word count and reading progress are shown in the progress bar above.
              </div>
            </div>
          </div>
        `

        // Add event listener for setup button
        const setupBtn = content.querySelector('[data-action="setup-api"]')
        if (setupBtn) {
          setupBtn.addEventListener("click", () => this.showApiKeySetup())
        }
        return
      }

      console.log("📋 API key available - showing summary interface")
      content.innerHTML = "🔄 Analyzing page content..."

      try {
        const pageContent = this.aiTutor.extractPageContent()

        // Check for last summary and show it immediately
        const lastSummary = await this.getLastSummary(window.location.href)

        // Always show the same layout with options at top
        let summaryContentHTML = ""
        let summaryNotice = ""

        if (lastSummary) {
          //console.log("📋 Found last summary, displaying immediately")
          summaryNotice = `
            <div class="last-summary-notice" style="display: flex; align-items: center; gap: 8px; margin-bottom: 15px; padding: 8px 12px; background: rgba(113, 152, 248, 0.1); border-radius: 6px; font-size: 12px; color: #7198f8;">
              <span style="font-size: 14px;">📋</span>
              <span>Last summary</span>
              <span style="margin-left: auto; color: #95a5a6;">${this.getTimeAgo(
                lastSummary.timestamp
              )}</span>
            </div>
          `
          // Use the displaySummary method to get consistent formatting with Q&A section
          summaryContentHTML = `<div id="temp-summary-container"></div>`
        } else {
          summaryContentHTML = `
            <div style="padding: 20px; text-align: center; color: #95a5a6;">
              Select a summary type to generate AI-powered insights
            </div>
          `
        }

        // Always show consistent layout
        content.innerHTML = `
          ${summaryNotice}
       
          <div id="summary-content" style="width: 100%; box-sizing: border-box;">
            ${summaryContentHTML}
          </div>
        `

        const summaryContent = document.getElementById("summary-content")

        // If we have a last summary, display it properly with Q&A section
        if (lastSummary) {
          const tempContainer = content.querySelector("#temp-summary-container")
          if (tempContainer) {
            this.displaySummary(
              {
                keyPoints: [this.parseAndFormatResponse(lastSummary.content)],
              },
              tempContainer
            )
          }
        } else {
          // No last summary found, generate a default "Main Points" summary
          // console.log(
          //  "🎯 No last summary found, generating an overview summary"
          //)

          // Set current summary type for default generation
          this.currentSummaryType = {
            length: "medium",
            focus: "key_learning_points",
          }

          summaryContent.innerHTML = "🔄 Generating AI summary..."
          try {
            const pageContent = this.aiTutor.extractPageContent()
            const languageInstruction = await this.getLanguageInstruction()
            const summary = await this.aiTutor.generateSummary(
              pageContent,
              {
                length: this.currentSummaryType.length,
                focus: this.currentSummaryType.focus,
                languageInstruction,
              },
              false // don't bypass cache for new summaries
            )
            this.displaySummary(summary, summaryContent)
          } catch (error) {
            summaryContent.innerHTML = `<div style="color: #dc3545;">Error generating summary: ${error.message}</div>`
          }
        }
      } catch (error) {
        content.innerHTML = "Error generating summary"
        console.error("Summary error:", error)
      }
    }

    // Helper method to format timestamp as "X ago"
    getTimeAgo(timestamp) {
      const now = Date.now()
      const diff = now - timestamp
      const minutes = Math.floor(diff / (1000 * 60))
      const hours = Math.floor(diff / (1000 * 60 * 60))
      const days = Math.floor(diff / (1000 * 60 * 60 * 24))

      if (minutes < 1) return "just now"
      if (minutes < 60) return `${minutes}m ago`
      if (hours < 24) return `${hours}h ago`
      if (days < 7) return `${days}d ago`
      return new Date(timestamp).toLocaleDateString()
    }

    displaySummary(summary, container) {
      // Show current summary timestamp at top in small font
      const currentTime = new Date()
        .toLocaleString("en-GB", {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        })
        .replace(",", "")

      // Use same styling as Q&A answers for consistency
      let html = `
        <div style="margin-top: 10px; padding: 10px; background: #0f2142; border-radius: 4px; color: #e8eaed; line-height: 1.4;">
          <div style="margin-bottom: 8px; padding: 4px 8px; background: #0a1f3d; border-radius: 4px; font-size: 9px; color: #7f8c8d; text-align: center;">
            AI Summary generated: ${currentTime}
          </div>`

      // 🎯 PURE DYNAMIC CONTENT DISPLAY - Use AI's structure exactly as returned
      if (summary._dynamicSections && summary._dynamicSections.length > 0) {
        console.log(
          "📋 Displaying",
          summary._dynamicSections.length,
          "dynamic sections"
        )

        summary._dynamicSections.forEach(section => {
          html += `
            <div style="margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #2c4a7c;">
              <strong style="color: #7198f8;">${section.emoji} ${
            section.title
          }:</strong><br>
              <div style="margin-top: 6px;">
                ${section.content.map(item => `• ${item}`).join("<br>")}
              </div>
            </div>
          `
        })
      } else {
        // Fallback for legacy summaries or parsing failures
        console.log(
          "� Using fallback display for summary without dynamic sections"
        )
        html += `
          <div style="margin-bottom: 12px; padding: 12px; background: #1a3a6b; border-radius: 6px; text-align: center; color: #95a5a6;">
            <div style="font-size: 14px; margin-bottom: 8px;">🤖 AI Response Processed</div>
            <div style="font-size: 11px;">Content structure: ${
              Object.keys(summary._rawData || {}).join(", ") || "Unknown"
            }</div>
          </div>
        `
      }

      // Add regeneration options
      html += `
        <div style="margin-bottom: 12px; padding-top: 12px; border-top: 0px solid #2c4a7c;">
          <strong style="color: #7198f8;">🔄 Switch Summary Type:</strong><br>
          <div style="margin: 10px 0; display: flex; gap: 5px; flex-wrap: wrap;">
            <button class="summary-switch" data-length="medium" data-focus="key_learning_points" style="padding: 4px 8px; background: #7198f8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
              📝 Main Points
            </button>
            <button class="summary-switch" data-length="short" data-focus="clinical_overview" style="padding: 4px 8px; background: #7198f8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
              💡 Short Recap
            </button>
            <button class="summary-switch" data-length="medium" data-focus="imaging_pearls" style="padding: 4px 8px; background: #7198f8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
              💎 Imaging Pearls
            </button>
            <button class="summary-switch" data-length="medium" data-focus="imaging_differential" style="padding: 4px 8px; background: #7198f8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
              🔍 Imaging Differential Key Points
            </button>
          </div>
          <div style="margin-top: 8px;">
            <button id="regenerate-current-summary" style="padding: 6px 12px; background: #fd7e14; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;">
              🔄 Regenerate Current Summary
            </button>
          </div>
        </div>
      `
      // <button id="show-summary-history" style="padding: 6px 12px; background: #ffc107; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
      //   📄 Summary History
      // </button>
      // Add Q&A section with history
      html += `
        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #2c4a7c;">
          <strong style="color: #7198f8;">❓ Ask About This Content</strong><br>
          <div style="margin: 8px 0;">
            <input type="text" id="question-input" placeholder="Ask a question about this content..." 
                   style="width: 100%; padding: 8px; border: 1px solid #2c4a7c; border-radius: 4px; background: #1a3a6b; color: white; font-size: 12px;">
          </div>
          <div style="display: flex; gap: 8px; margin-bottom: 10px;">
            <button id="ask-question" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
              🤔 Get Answer
            </button>
            <button id="show-qa-history" style="padding: 6px 12px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
              📜 Q&A History
            </button>

          </div>
          <div id="qa-history-content" style="margin-top: 10px; display: none;"></div>
          <div id="summary-history-content" style="margin-top: 10px; display: none;"></div>
          <div id="answer-content" style="margin-top: 10px; padding: 10px; background: #0f2142; border-radius: 4px; display: none;"></div>
        </div>
      </div>
      `

      container.innerHTML = html

      // Add event listeners for summary type switching (check cache first)
      const switchButtons = container.querySelectorAll(".summary-switch")
      switchButtons.forEach(button => {
        button.addEventListener("click", async () => {
          const length = button.getAttribute("data-length")
          const focus = button.getAttribute("data-focus")

          // Store current summary type for regeneration
          this.currentSummaryType = { length, focus }

          // Visual feedback
          const originalText = button.innerHTML
          button.innerHTML = "🔄"
          button.disabled = true

          // Show loading in the container
          container.innerHTML = "🔄 Loading summary..."

          try {
            const pageContent = this.aiTutor.extractPageContent()
            const languageInstruction = await this.getLanguageInstruction()

            // First try to get from cache (bypassCache: false)
            const summary = await this.aiTutor.generateSummary(
              pageContent,
              {
                length: length,
                focus: focus,
                languageInstruction,
              },
              false // Check cache first, generate only if missing
            )

            this.displaySummary(summary, container)
          } catch (error) {
            container.innerHTML = `<div style="color: #dc3545;">Error loading summary: ${error.message}</div>`
            console.error("Summary switching error:", error)
          }
        })
      })

      // Add event listener for regenerating current summary (force bypass cache)
      const regenerateButton = container.querySelector(
        "#regenerate-current-summary"
      )
      if (regenerateButton) {
        regenerateButton.addEventListener("click", async () => {
          // Check if we have a current summary type to regenerate
          if (!this.currentSummaryType) {
            // Default to key_learning_points if no current type
            this.currentSummaryType = {
              length: "medium",
              focus: "key_learning_points",
            }
          }

          // Visual feedback
          regenerateButton.innerHTML = "🔄 Regenerating..."
          regenerateButton.disabled = true

          // Show loading in the container
          container.innerHTML = "🔄 Generating fresh summary..."

          try {
            const pageContent = this.aiTutor.extractPageContent()
            const languageInstruction = await this.getLanguageInstruction()

            // Force regeneration by bypassing cache
            const summary = await this.aiTutor.generateSummary(
              pageContent,
              {
                length: this.currentSummaryType.length,
                focus: this.currentSummaryType.focus,
                languageInstruction,
              },
              true // Force bypass cache for fresh content
            )

            this.displaySummary(summary, container)
          } catch (error) {
            container.innerHTML = `<div style="color: #dc3545;">Error regenerating summary: ${error.message}</div>`
            console.error("Summary regeneration error:", error)
          }
        })
      }

      // Add Q&A functionality
      const askButton = container.querySelector("#ask-question")
      const questionInput = container.querySelector("#question-input")
      const answerContent = container.querySelector("#answer-content")
      const showHistoryButton = container.querySelector("#show-qa-history")
      const historyContent = container.querySelector("#qa-history-content")

      if (askButton && questionInput) {
        const handleQuestion = async () => {
          const question = questionInput.value.trim()
          if (!question) return

          askButton.textContent = "🔄 Thinking..."
          askButton.disabled = true
          answerContent.style.display = "block"
          answerContent.innerHTML = "🤔 Analyzing your question..."

          try {
            const pageContent = this.aiTutor.extractPageContent()
            const languageInstruction = await this.getLanguageInstruction()

            // Debug logging to verify language instruction is applied
            if (languageInstruction) {
              console.log(
                `🌐 Language instruction for Q&A: ${languageInstruction.substring(
                  0,
                  50
                )}...`
              )
              console.log(
                `🔍 Original question: ${question.substring(0, 100)}...`
              )
            }

            const answer = await this.aiTutor.answerQuestion(
              question,
              pageContent,
              languageInstruction
            )
            answerContent.innerHTML = `<strong>💡 Answer:</strong><br>${answer}`
            questionInput.value = "" // Clear input after successful answer

            // Refresh history button to show new entry exists
            if (showHistoryButton) {
              showHistoryButton.style.background = "#ffc107"
              showHistoryButton.textContent = "📜 New History!"

              // If history content is currently visible and showing "no questions" message, refresh it
              if (historyContent.style.display === "block") {
                const pageUrl = window.location.pathname
                const updatedHistory = await this.aiTutor.getQAHistory(pageUrl)
                if (updatedHistory.length > 0) {
                  // Auto-refresh the history display to show the new Q&A
                  showHistoryButton.click() // This will hide current content
                  setTimeout(() => showHistoryButton.click(), 100) // Then show updated content
                }
              }

              setTimeout(() => {
                showHistoryButton.style.background = "#17a2b8"
                showHistoryButton.textContent = "📜 View History"
              }, 3000)
            }
          } catch (error) {
            answerContent.innerHTML = `<div style="color: #dc3545;">Error: ${error.message}</div>`
          } finally {
            askButton.textContent = "🤔 Get Answer"
            askButton.disabled = false
          }
        }

        askButton.addEventListener("click", handleQuestion)
        questionInput.addEventListener("keypress", e => {
          if (e.key === "Enter") {
            handleQuestion()
          }
        })
      }

      // Add history functionality
      if (showHistoryButton && historyContent) {
        showHistoryButton.addEventListener("click", async () => {
          const pageUrl = window.location.pathname
          const history = await this.aiTutor.getQAHistory(pageUrl)

          if (history.length === 0) {
            historyContent.innerHTML = `
              <div style="padding: 10px; background: #1a3a6b; border-radius: 4px; color: #b0bec5; text-align: center;">
                📜 No questions asked on this page yet.<br>
                <span style="font-size: 10px;">Ask your first question above!</span>
              </div>
            `
          } else {
            let historyHTML = `
              <div style="max-height: 300px; overflow-y: auto; border: 1px solid #2c4a7c; border-radius: 4px;">
                <div style="padding: 8px; background: #1a3a6b; font-weight: bold; border-bottom: 1px solid #2c4a7c;">
                  📜 Q&A History for this page (${history.length} entries)
                </div>
            `

            history.forEach((entry, index) => {
              // Format timestamp properly to EU format (DD.MM.YYYY HH:MM)
              const entryTime = entry.timestamp
                ? new Date(entry.timestamp)
                    .toLocaleString("en-GB", {
                      day: "2-digit",
                      month: "2-digit",
                      year: "numeric",
                      hour: "2-digit",
                      minute: "2-digit",
                      hour12: false,
                    })
                    .replace(",", "")
                : "Unknown time"

              historyHTML += `
                <div style="padding: 10px; border-bottom: 1px solid #2c4a7c; background: ${
                  index % 2 === 0 ? "#0f2142" : "#123262"
                };">
                  <div style="font-weight: bold; color: #7198f8; margin-bottom: 5px;">
                    ❓ ${entry.question}
                  </div>
                  <div style="margin-bottom: 5px; font-size: 11px; color: #95a5a6;">
                    🕐 ${entryTime}
                  </div>
                  <div style="color: #e8eaed; font-size: 12px; line-height: 1.4;">
                    ${entry.answer}
                  </div>
                </div>
              `
            })

            historyHTML += `</div>`
            historyContent.innerHTML = historyHTML
          }

          // Toggle visibility
          if (historyContent.style.display === "none") {
            historyContent.style.display = "block"
            showHistoryButton.textContent = "🔼 Hide Q&A History"
          } else {
            historyContent.style.display = "none"
            showHistoryButton.textContent = "📜 Q&A History"
          }
        })
      }

      // Add summary history functionality
      const showSummaryHistoryButton = container.querySelector(
        "#show-summary-history"
      )
      const summaryHistoryContent = container.querySelector(
        "#summary-history-content"
      )

      if (showSummaryHistoryButton && summaryHistoryContent) {
        showSummaryHistoryButton.addEventListener("click", async () => {
          const pageUrl = window.location.pathname
          const summaries = await this.getSummaryHistory(pageUrl)

          if (summaries.length === 0) {
            summaryHistoryContent.innerHTML = `
              <div style="padding: 10px; background: #1a3a6b; border-radius: 4px; color: #b0bec5; text-align: center;">
                📄 No summaries generated for this page yet.<br>
                <span style="font-size: 10px;">Generate your first summary above!</span>
              </div>
            `
          } else {
            let summaryHTML = `
              <div style="max-height: 300px; overflow-y: auto; border: 1px solid #2c4a7c; border-radius: 4px;">
                <div style="padding: 8px; background: #1a3a6b; font-weight: bold; border-bottom: 1px solid #2c4a7c;">
                  📄 Summary History for this page (${summaries.length} entries)
                </div>
            `

            summaries.forEach((entry, index) => {
              // Format timestamp properly to EU format (DD.MM.YYYY HH:MM)
              const entryTime = entry.timestamp
                ? new Date(entry.timestamp)
                    .toLocaleString("en-GB", {
                      day: "2-digit",
                      month: "2-digit",
                      year: "numeric",
                      hour: "2-digit",
                      minute: "2-digit",
                      hour12: false,
                    })
                    .replace(",", "")
                : "Unknown time"

              summaryHTML += `
                <div style="padding: 10px; border-bottom: 1px solid #2c4a7c; background: ${
                  index % 2 === 0 ? "#0f2142" : "#123262"
                };">
                  <div style="font-weight: bold; color: #ffc107; margin-bottom: 5px;">
                    📄 Summary ${index + 1}
                  </div>
                  <div style="margin-bottom: 5px; font-size: 11px; color: #95a5a6;">
                    🕐 ${entryTime}
                  </div>
                  <div style="color: #e8eaed; font-size: 12px; line-height: 1.4;">
                    ${this.formatSummaryContentSimple(entry.content)}
                  </div>
                </div>
              `
            })

            summaryHTML += `</div>`
            summaryHistoryContent.innerHTML = summaryHTML
          }

          // Toggle visibility
          if (summaryHistoryContent.style.display === "none") {
            summaryHistoryContent.style.display = "block"
            showSummaryHistoryButton.textContent = "🔼 Hide Summary History"
          } else {
            summaryHistoryContent.style.display = "none"
            showSummaryHistoryButton.textContent = "📄 Summary History"
          }
        })
      }
    }

    async generateQuiz() {
      const content = document.getElementById("quiz-content")

      // Check if AI features are available
      if (!this.aiTutor.hasApiKey()) {
        content.innerHTML = `
          <div style="text-align: center; padding: 20px;">
            <h3>🔑 AI Features Require API Key</h3>
            <p>To use AI-powered quizzes and summaries, please configure your Mistral API key.</p>
            <button data-action="setup-api" style="padding: 12px 20px; background: #7198f8; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 10px;">
              🔧 Setup API Key
            </button>
            <p style="font-size: 12px; color: #666; margin-top: 15px;">
              Your API key is stored securely in your browser and never transmitted to external servers except Mistral AI.
            </p>
          </div>
        `

        // Add event listener for setup button
        const setupBtn = content.querySelector('[data-action="setup-api"]')
        if (setupBtn) {
          setupBtn.addEventListener("click", () => this.showApiKeySetup())
        }
        return
      }

      content.innerHTML = "Generating quiz question..."

      try {
        const pageContent = this.aiTutor.extractPageContent()
        this.currentQuiz = await this.aiTutor.generateQuizQuestion(pageContent)

        content.innerHTML = `
                    <div class="quiz-question">
                        <strong>❓ ${this.currentQuiz.question}</strong>
                        <div class="quiz-options">
                            ${this.currentQuiz.options
                              .map(
                                (option, index) =>
                                  `<button class="quiz-option" onclick="window.raTutor.ui.answerQuiz(${index})">${option}</button>`
                              )
                              .join("")}
                        </div>
                    </div>
                `
      } catch (error) {
        content.innerHTML = "Error generating quiz"
        console.error("Quiz error:", error)
      }
    }

    answerQuiz(selectedIndex) {
      if (!this.currentQuiz) return

      const isCorrect = selectedIndex === this.currentQuiz.correct
      const content = document.getElementById("quiz-content")

      // Show feedback
      content.innerHTML = `
                <div class="quiz-question">
                    <strong>❓ ${this.currentQuiz.question}</strong>
                    <div style="margin-top: 15px;">
                        <div style="padding: 15px; border-radius: 8px; background: ${
                          isCorrect ? "#d4edda" : "#f8d7da"
                        }; color: ${isCorrect ? "#155724" : "#721c24"};">
                            ${isCorrect ? "✅ Correct!" : "❌ Incorrect"}
                        </div>
                        <div class="ai-response">
                            <strong>💡 Explanation:</strong><br>
                            ${this.currentQuiz.explanation}
                        </div>
                        <button onclick="window.raTutor.ui.generateQuiz()" style="width: 100%; margin-top: 15px; padding: 12px; background: linear-gradient(135deg, #7198f8 0%, #5577e6 100%); color: white; border: none; border-radius: 8px; cursor: pointer;">
                            🔄 Next Question
                        </button>
                    </div>
                </div>
            `
    }

    switchTab(tabName) {
      // Remove active class from all tabs and buttons
      document
        .querySelectorAll(".tutor-tab")
        .forEach(tab => tab.classList.remove("active"))
      document
        .querySelectorAll(".tab-button")
        .forEach(btn => btn.classList.remove("active"))

      // Add active class to selected tab and button
      document.getElementById(`${tabName}-tab`).classList.add("active")
      document.querySelector(`[data-tab="${tabName}"]`).classList.add("active")

      this.currentTab = tabName

      // Update content based on tab
      if (tabName === "summary") {
        this.updateSummaryTab()
      }
      // Progress tab removed - stats now in dedicated section
    }

    togglePanel() {
      this.isMinimized = !this.isMinimized
      const panel = document.getElementById("ra-tutor-panel")
      const toggleButton = document.getElementById("ra-tutor-toggle")

      // Use direct style manipulation like the working example
      if (this.isMinimized) {
        panel.style.transform = "translateX(calc(100% - 50px))"
        if (toggleButton) toggleButton.style.display = "block"
      } else {
        panel.style.transform = "translateX(0)"
        if (toggleButton) toggleButton.style.display = "none"
        this.switchTab(this.currentTab) // Refresh current tab
      }
    }

    formatTime(milliseconds) {
      const minutes = Math.floor(milliseconds / 60000)
      const hours = Math.floor(minutes / 60)

      if (hours > 0) {
        return `${hours}h ${minutes % 60}m`
      }
      return `${minutes}m`
    }

    showApiKeySetup() {
      // Create secure API key setup modal
      const overlay = document.createElement("div")
      overlay.className = "overlay"
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
      `

      const modal = document.createElement("div")
      modal.style.cssText = `
        background: white;
        padding: 30px;
        border-radius: 15px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      `

      modal.innerHTML = `
        <h3 style="margin-top: 0; color: #333;">🔑 Mistral AI API Key Setup</h3>
        <p style="color: #666; line-height: 1.5;">
          To use AI-powered features, you'll need a Mistral AI API key. Your key is stored securely in your browser only.
        </p>
        <div style="margin: 20px 0;">
          <label style="display: block; margin-bottom: 8px; font-weight: bold;">API Key:</label>
          <input type="password" id="mistral-api-key" placeholder="Enter your Mistral API key" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;">
        </div>
        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 13px; color: #666;">
          <strong>🔒 Privacy & Security:</strong><br>
          • Your API key is stored only in your browser<br>
          • Never transmitted except directly to Mistral AI<br>
          • Can be deleted anytime from the settings<br>
          • No personal data collected or transmitted, even to Mistral AI
        </div>
        <div style="display: flex; gap: 10px; margin-top: 25px;">
          <button id="save-api-key" style="flex: 1; padding: 12px; background: #7198f8; color: white; border: none; border-radius: 8px; cursor: pointer;">
            💾 Save Key
          </button>
          <button id="cancel-api-setup" style="flex: 1; padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer;">
            Cancel
          </button>
        </div>
        <p style="font-size: 12px; color: #888; margin-top: 15px; text-align: center;">
          Get your API key at: <a href="https://console.mistral.ai/" target="_blank" style="color: #7198f8;">console.mistral.ai</a>
        </p>
      `

      overlay.appendChild(modal)
      document.body.appendChild(overlay)

      // Event listeners
      document
        .getElementById("save-api-key")
        .addEventListener("click", async () => {
          const apiKey = document.getElementById("mistral-api-key").value.trim()
          if (apiKey) {
            try {
              console.log("🔑 Saving API key...")
              // Store securely - use native GM.setValue
              await GM.setValue("mistral_api_key", apiKey)
              // Update AITutor instance
              this.aiTutor.apiKey = apiKey
              console.log("🔑 API key updated in AITutor instance")

              // Close modal first
              overlay.remove()

              // Force refresh the UI state after a small delay to ensure everything is updated
              setTimeout(() => {
                console.log("🔑 Refreshing UI after API key save...")
                console.log(
                  "🔑 hasApiKey() now returns:",
                  this.aiTutor.hasApiKey()
                )
                // Refresh current tab to show new features
                this.switchTab(this.currentTab)
              }, 100)

              console.log("🔑 API key saved securely in local storage")
              alert("✅ API key saved successfully!")
            } catch (error) {
              console.error("🔑 Error saving API key:", error)
              alert("❌ Error saving API key. Please try again.")
            }
          } else {
            alert("Please enter a valid API key")
          }
        })

      document
        .getElementById("cancel-api-setup")
        .addEventListener("click", () => {
          overlay.remove()
        })

      // Close on overlay click
      overlay.addEventListener("click", e => {
        if (e.target === overlay) {
          overlay.remove()
        }
      })
    }

    async clearAllData() {
      if (
        confirm(
          "⚠️ This will delete all your Q&A history, summaries, and API key. This cannot be undone. Continue?"
        )
      ) {
        try {
          // Clear API key
          GM.deleteValue("mistral_api_key")
          this.aiTutor.apiKey = null

          // Clear language preference
          GM.deleteValue("ra_tutor_language")

          // Clear Q&A and summary data
          const allKeys = await GM.listValues()
          for (const key of allKeys) {
            if (
              key.startsWith("ra_tutor_gdpr_") ||
              key.startsWith("ai_cache_")
            ) {
              await GM.deleteValue(key)
            }
          }

          console.log("‼️ All user data cleared successfully ‼️")
          alert("✅ All data cleared successfully.")
          // Refresh the current tab
          this.switchTab(this.currentTab)
        } catch (error) {
          console.error("Error clearing data:", error)
          alert("❌ Error clearing data. Please try again.")
        }
      }
    }

    // ========================================
    // ⚙️ COMBINED SETTINGS & STATS PANEL
    // ========================================

    // Combined toggle for settings panel (now includes stats)
    toggleSettings() {
      const settingsContent = document.getElementById("settings-content")

      if (settingsContent.style.display === "none") {
        settingsContent.style.display = "block"
        // Update both settings and stats when opened
        this.updateSettingsContent()
      } else {
        settingsContent.style.display = "none"
      }
    }

    async saveLanguagePreference(language) {
      try {
        await GM.setValue("ra_tutor_language", language)
        //console.log(`🌐 Language preference saved: ${language}`)

        // Show brief confirmation with language name
        const languageNames = {
          english: "English",
          slovenian: "Slovenian",
          croatian: "Croatian",
          serbian: "Serbian",
        }

        const languageSelect = document.getElementById("ai-language-select")
        if (languageSelect) {
          const originalStyle = languageSelect.style.background
          languageSelect.style.background = "#28a745"

          // Also show a brief tooltip or alert
          setTimeout(() => {
            languageSelect.style.background = originalStyle
          }, 1500)

          //console.log(`🌐 AI will now respond in: ${languageNames[language]}`)
        }
      } catch (error) {
        console.error("Error saving language preference:", error)
      }
    }
    async getLanguagePreference() {
      try {
        const language = await GM.getValue("ra_tutor_language", "english")
        return language
      } catch (error) {
        console.error("Error loading language preference:", error)
        return "english" // Default fallback
      }
    }

    async getLanguageInstruction() {
      const language = await this.getLanguagePreference()
      console.log(`🌐 Current language preference: ${language}`)
      const instructions = {
        english: "", // No additional instruction needed for English
        slovenian:
          "\n\nIMPORTANT: You must respond entirely in Slovenian language (slovenščina). Do not use English except for medical terms that don't have direct Slovenian translations.",
        croatian:
          "\n\nIMPORTANT: You must respond entirely in Croatian language (hrvatski). Do not use English except for medical terms that don't have direct Croatian translations.",
        serbian:
          "\n\nIMPORTANT: You must respond entirely in Serbian language (srpski). Do not use English except for medical terms that don't have direct Serbian translations.",
      }
      const instruction = instructions[language] || ""
      console.log(
        `🌐 Generated language instruction: "${instruction.substring(0, 50)}${
          instruction.length > 50 ? "..." : ""
        }"`
      )
      return instruction
    }

    async showDataOverview() {
      try {
        // Get all unified AI responses for overview stats
        const allGMKeys = await GM.listValues()
        const responseKeys = allGMKeys.filter(key =>
          key.startsWith("ai_response_")
        )

        // Calculate totals from unified storage
        let totalQAEntries = 0
        let totalSummaries = 0
        let daysWithActivity = new Set()
        let uniquePagesWithSummaries = new Set()
        let uniquePagesWithQA = new Set()

        // Process all unified AI responses
        for (const key of responseKeys) {
          try {
            const data = await GM.getValue(key, null)
            if (data) {
              const response = JSON.parse(data)

              // Count by type
              if (response.type === "qa") {
                totalQAEntries++
                uniquePagesWithQA.add(response.pageUrl)
              } else if (response.type === "summary") {
                totalSummaries++
                uniquePagesWithSummaries.add(response.pageUrl)
              }

              // Add dates from timestamps
              if (response.timestamp) {
                const date = new Date(response.timestamp)
                  .toISOString()
                  .split("T")[0]
                daysWithActivity.add(date)
              }
            }
          } catch (error) {
            console.warn("Error parsing AI response:", error)
          }
        }

        // Get API usage statistics
        const tokenUsageLogs = await this.aiTutor.getTokenUsageLogs()
        let totalApiCalls = 0
        let totalTokens = 0
        let totalCost = 0
        let modelUsage = {}
        let costByType = {}
        let recentUsage = { last7Days: 0, last30Days: 0 }

        const now = Date.now()
        const sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1000
        const thirtyDaysAgo = now - 30 * 24 * 60 * 60 * 1000

        tokenUsageLogs.forEach(log => {
          totalApiCalls++
          totalTokens += log.tokens.total || 0
          totalCost += log.cost || 0

          // Track model usage
          const model = log.model || "unknown"
          if (!modelUsage[model]) {
            modelUsage[model] = { calls: 0, tokens: 0, cost: 0 }
          }
          modelUsage[model].calls++
          modelUsage[model].tokens += log.tokens.total || 0
          modelUsage[model].cost += log.cost || 0

          // Track cost by operation type
          const type = log.type || "unknown"
          if (!costByType[type]) {
            costByType[type] = { calls: 0, cost: 0, tokens: 0 }
          }
          costByType[type].calls++
          costByType[type].cost += log.cost || 0
          costByType[type].tokens += log.tokens.total || 0

          // Track recent usage
          if (log.timestamp >= sevenDaysAgo) {
            recentUsage.last7Days++
          }
          if (log.timestamp >= thirtyDaysAgo) {
            recentUsage.last30Days++
          }
        })

        // Create day-by-day activity data
        const activityByDate = await this.getActivityByDate()

        this.showDataModal(
          "📊 Learning Activity Overview",
          `
          <div style="background: #1a3a6b; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <strong>📈 Your Learning Journey:</strong><br>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
              <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 18px; color: #7198f8; font-weight: bold;">${
                  daysWithActivity.size
                }</div>
                <div style="font-size: 11px; color: #b0bec5;">Active Days</div>
              </div>
              <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 18px; color: #7198f8; font-weight: bold;">${Math.max(
                  uniquePagesWithSummaries.size,
                  uniquePagesWithQA.size
                )}</div>
                <div style="font-size: 11px; color: #b0bec5;">Pages Analyzed</div>
              </div>
              <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 18px; color: #7198f8; font-weight: bold;">${totalQAEntries}</div>
                <div style="font-size: 11px; color: #b0bec5;">Questions Asked</div>
              </div>
              <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 18px; color: #7198f8; font-weight: bold;">${totalSummaries}</div>
                <div style="font-size: 11px; color: #b0bec5;">AI Summaries</div>
              </div>
            </div>
          </div>

          <div style="background: #1a3a6b; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <strong>🤖 AI API Usage Statistics:</strong>
            ${
              totalApiCalls === 0
                ? `
              <div style="margin-top: 10px; padding: 12px; background: #123262; border-radius: 6px; text-align: center; color: #7f8c8d;">
                <div style="font-size: 14px; margin-bottom: 6px;">📊 No API usage yet</div>
                <div style="font-size: 11px;">Generate summaries or ask questions to see statistics here</div>
              </div>
            `
                : `
              <br>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="font-size: 18px; color: #28a745; font-weight: bold;">${totalApiCalls}</div>
                  <div style="font-size: 11px; color: #b0bec5;">Total API Calls</div>
                </div>
                <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="font-size: 18px; color: #28a745; font-weight: bold;">${totalTokens.toLocaleString()}</div>
                  <div style="font-size: 11px; color: #b0bec5;">Total Tokens</div>
                </div>
                <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="font-size: 18px; color: #28a745; font-weight: bold;">€${totalCost.toFixed(
                    4
                  )}</div>
                  <div style="font-size: 11px; color: #b0bec5;">Total Cost</div>
                </div>
                <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="font-size: 18px; color: #28a745; font-weight: bold;">${
                    totalApiCalls > 0
                      ? (totalTokens / totalApiCalls).toFixed(0)
                      : "0"
                  }</div>
                  <div style="font-size: 11px; color: #b0bec5;">Avg Tokens/Call</div>
                </div>
              </div>
              
              ${
                totalApiCalls > 0
                  ? `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                  <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 16px; color: #ffc107; font-weight: bold;">${recentUsage.last7Days}</div>
                    <div style="font-size: 11px; color: #b0bec5;">Last 7 Days</div>
                  </div>
                  <div style="background: #123262; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 16px; color: #ffc107; font-weight: bold;">${recentUsage.last30Days}</div>
                    <div style="font-size: 11px; color: #b0bec5;">Last 30 Days</div>
                  </div>
                </div>
              `
                  : ""
              }

              ${
                Object.keys(modelUsage).length > 0
                  ? `
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #2c4a7c;">
                  <strong style="color: #7198f8; font-size: 12px;">🔧 Model Usage Breakdown:</strong>
                  <div style="margin-top: 8px;">
                    ${Object.entries(modelUsage)
                      .map(
                        ([model, stats]) => `
                      <div style="margin-bottom: 6px; padding: 6px; background: #0f2142; border-radius: 4px; font-size: 11px;">
                        <strong style="color: #7198f8;">${model}:</strong> 
                        ${
                          stats.calls
                        } calls • ${stats.tokens.toLocaleString()} tokens • €${stats.cost.toFixed(
                          4
                        )}
                      </div>
                    `
                      )
                      .join("")}
                  </div>
                </div>
              `
                  : ""
              }

              ${
                Object.keys(costByType).length > 0
                  ? `
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #2c4a7c;">
                  <strong style="color: #7198f8; font-size: 12px;">📊 Usage by Operation Type:</strong>
                  <div style="margin-top: 8px;">
                    ${Object.entries(costByType)
                      .map(
                        ([type, stats]) => `
                      <div style="margin-bottom: 6px; padding: 6px; background: #0f2142; border-radius: 4px; font-size: 11px;">
                        <strong style="color: #7198f8;">${
                          type.charAt(0).toUpperCase() + type.slice(1)
                        }:</strong> 
                        ${
                          stats.calls
                        } calls • ${stats.tokens.toLocaleString()} tokens • €${stats.cost.toFixed(
                          4
                        )}
                      </div>
                    `
                      )
                      .join("")}
                  </div>
                </div>
              `
                  : ""
              }

              <div style="margin-top: 12px; padding: 10px; background: rgba(113, 152, 248, 0.1); border-radius: 6px; border-left: 4px solid #7198f8;">
                <div style="font-size: 11px; color: #b0bec5; line-height: 1.4;">
                  <strong style="color: #7198f8;">💡 About API Usage:</strong><br>
                  • Token usage varies based on content length and complexity<br>
                  • Costs are calculated using Mistral AI's current pricing<br>
                  • Export your data to analyze usage patterns in detail
                </div>
              </div>
            `
            }
          </div>
          
          <div style="margin: 15px 0;">
            <strong style="color: #7198f8;">📅 Recent Activity:</strong>
            <div style="max-height: 400px; overflow-y: auto; margin-top: 10px;">
              ${activityByDate}
            </div>
          </div>
        `
        )
      } catch (error) {
        console.error("📊 Error in showDataOverview:", error)
        alert(`❌ Error viewing data overview: ${error.message}`)
      }
    }

    async getActivityByDate() {
      try {
        const allQAEntries = []
        const allSummaries = []

        // Get all unified AI responses
        const allGMKeys = await GM.listValues()
        const responseKeys = allGMKeys.filter(key =>
          key.startsWith("ai_response_")
        )

        for (const key of responseKeys) {
          try {
            const data = await GM.getValue(key, null)
            if (data) {
              const response = JSON.parse(data)

              if (
                response.type === "qa" &&
                response.request.question &&
                response.response.parsed
              ) {
                allQAEntries.push({
                  question: response.request.question,
                  answer: response.response.parsed,
                  page: response.pageTitle || "Unknown Page",
                  timestamp: response.timestamp,
                })
              } else if (
                response.type === "summary" &&
                response.response.parsed
              ) {
                allSummaries.push({
                  content: response.response.parsed,
                  page: response.pageTitle || "Unknown Page",
                  timestamp: response.timestamp,
                  focus: response.request.focus || "general",
                })
              }
            }
          } catch (error) {
            console.warn("Error loading AI response:", error)
          }
        }

        // Sort both by timestamp (newest first)
        allQAEntries.sort(
          (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
        )
        allSummaries.sort(
          (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
        )

        allSummaries.length > 0
          ? `<div style="margin-bottom: 12px; padding: 8px; background: #1a3a6b; border-radius: 6px; text-align: center;">
               <strong style="color: #ffc107;">📄 AI Summaries (${
                 allSummaries.length
               })</strong>
             </div>
             <div style="max-height: 600px; overflow-y: auto; padding-right: 5px;">
               ${allSummaries
                 .map((summary, index) => {
                   const summaryId = `summary-simple-${index}`

                   return `<div style="margin-bottom: 10px; padding: 8px; background: #123262; border-radius: 6px; border-left: 4px solid #ffc107;">
                   <div style="font-weight: bold; color: #ffc107; margin-bottom: 4px; font-size: 12px; cursor: pointer;" onclick="
                     const content = document.getElementById('${summaryId}-content');
                     const arrow = document.getElementById('${summaryId}-arrow');
                     if (content.style.display === 'none') {
                       content.style.display = 'block';
                       arrow.textContent = '�';
                     } else {
                       content.style.display = 'none';
                       arrow.textContent = '▶️';
                     }
                   ">
                     <span id="${summaryId}-arrow">▶️</span> 📄 ${summary.page}
                   </div>
                   <div id="${summaryId}-content" style="display: none; color: #e8eaed; font-size: 11px; line-height: 1.4;">
                     ${this.formatSummaryContent(summary.content)}
                   </div>
                 </div>`
                 })
                 .join("")}
             </div>`
          : `<div style="padding: 20px; text-align: center; color: #7f8c8d; border: 1px dashed #2c4a7c; border-radius: 6px;">
               <div style="font-size: 12px;">📄 No summaries yet</div>
               <div style="font-size: 10px; margin-top: 4px;">Generate summaries to see them here</div>
             </div>`

        // Expandable Q&A list with clickable entries
        let qaList = ""
        if (allQAEntries.length > 0) {
          qaList = `<h4>❓ Questions & Answers (${allQAEntries.length}):</h4>`
          qaList += `<div style="max-height: 400px; overflow-y: auto; margin: 10px 0;">`

          allQAEntries.forEach((qa, index) => {
            const qaId = `qa-simple-${index}`
            qaList += `
              <div style="margin-bottom: 10px; padding: 8px; background: #123262; border-radius: 6px; border-left: 4px solid #28a745;">
                <div style="font-weight: bold; color: #28a745; margin-bottom: 4px; font-size: 12px; cursor: pointer;" onclick="
                  const content = document.getElementById('${qaId}-content');
                  const arrow = document.getElementById('${qaId}-arrow');
                  if (content.style.display === 'none') {
                    content.style.display = 'block';
                    arrow.textContent = '▼';
                  } else {
                    content.style.display = 'none';
                    arrow.textContent = '▶️';
                  }
                ">
                  <span id="${qaId}-arrow">▶️</span> ❓ ${qa.question}
                </div>
                <div style="color: #b0bec5; font-size: 10px; margin-bottom: 4px;">
                  📄 ${qa.page} • ${new Date(qa.timestamp).toLocaleDateString()}
                </div>
                <div id="${qaId}-content" style="display: none; color: #e8eaed; font-size: 11px; line-height: 1.4; margin-top: 8px; padding: 8px; background: #0f2142; border-radius: 4px;">
                  <strong style="color: #7198f8;">💡 Answer:</strong><br>
                  <div style="margin-top: 4px;">${
                    qa.answer || "Answer not available"
                  }</div>
                </div>
              </div>
            `
          })
          qaList += `</div>`
        } else {
          qaList = `<h4>❓ Questions & Answers:</h4><p style="color: #7f8c8d;">No questions asked yet</p>`
        }

        let summariesList = ""
        if (allSummaries.length > 0) {
          summariesList = `<h4>📄 AI Summaries (${allSummaries.length}):</h4><ul style="margin: 10px 0; padding-left: 20px;">`
          allSummaries.forEach(summary => {
            summariesList += `<li style="margin: 8px 0; font-size: 12px;"><strong>${
              summary.page
            }</strong> (${new Date(
              summary.timestamp
            ).toLocaleDateString()})</li>`
          })
          summariesList += `</ul>`
        } else {
          summariesList = `<h4>📄 AI Summaries:</h4><p style="color: #7f8c8d;">No summaries generated yet</p>`
        }

        return `
          <div style="padding: 15px;">
            ${qaList}
            <hr style="margin: 20px 0; border-color: #2c4a7c;">
            ${summariesList}
          </div>
        `
      } catch (error) {
        console.error("Error generating activity overview:", error)
        return `<div style="color: #dc3545;">Error loading activity data</div>`
      }
    }

    formatSummaryContent(summary) {
      if (!summary) return "No content available"

      let html = ""

      // Reading time
      if (summary.readingTime) {
        html += `
          <div style="margin-bottom: 8px; padding: 6px; background: #0f2142; border-radius: 4px;">
            <strong style="color: #7198f8;">📄 Reading Time:</strong> ${summary.readingTime} min
          </div>
        `
      }

      // Key Points
      if (summary.keyPoints && summary.keyPoints.length > 0) {
        html += `
          <div style="margin-bottom: 8px; padding: 6px; background: #0f2142; border-radius: 4px;">
            <strong style="color: #7198f8;">🎯 Key Learning Points:</strong><br>
            <div style="margin-top: 4px;">
              ${summary.keyPoints.map(point => `• ${point}`).join("<br>")}
            </div>
          </div>
        `
      }

      // Clinical Pearls
      if (summary.clinicalPearls && summary.clinicalPearls.length > 0) {
        html += `
          <div style="margin-bottom: 8px; padding: 6px; background: #0f2142; border-radius: 4px;">
            <strong style="color: #7198f8;">💎 Clinical Pearls:</strong><br>
            <div style="margin-top: 4px;">
              ${summary.clinicalPearls.map(pearl => `• ${pearl}`).join("<br>")}
            </div>
          </div>
        `
      }

      // Differentials
      if (summary.differentials && summary.differentials.length > 0) {
        html += `
          <div style="margin-bottom: 8px; padding: 6px; background: #0f2142; border-radius: 4px;">
            <strong style="color: #7198f8;">🔍 Differential Diagnoses:</strong><br>
            <div style="margin-top: 4px;">
              ${summary.differentials.map(diff => `• ${diff}`).join("<br>")}
            </div>
          </div>
        `
      }

      // Imaging Approach
      if (summary.imagingApproach && summary.imagingApproach.length > 0) {
        html += `
          <div style="margin-bottom: 8px; padding: 6px; background: #0f2142; border-radius: 4px;">
            <strong style="color: #7198f8;">📋 Imaging Approach:</strong><br>
            <div style="margin-top: 4px;">
              ${summary.imagingApproach
                .map((step, index) => `${index + 1}. ${step}`)
                .join("<br>")}
            </div>
          </div>
        `
      }

      // Diagnostic Approach
      if (summary.diagnosticApproach && summary.diagnosticApproach.length > 0) {
        html += `
          <div style="margin-bottom: 8px; padding: 6px; background: #0f2142; border-radius: 4px;">
            <strong style="color: #7198f8;">🩺 Diagnostic Approach:</strong><br>
            <div style="margin-top: 4px;">
              ${summary.diagnosticApproach
                .map((step, index) => `${index + 1}. ${step}`)
                .join("<br>")}
            </div>
          </div>
        `
      }

      return html || "Summary content not available"
    }

    formatSummaryContentSimple(summary) {
      if (!summary) return "No content available"

      let html = ""

      // Convert markdown formatting to HTML and show key points
      if (summary.keyPoints && summary.keyPoints.length > 0) {
        html += `<div style="margin-bottom: 8px;"><strong>🎯 Key Points:</strong><br>`
        summary.keyPoints.slice(0, 3).forEach(point => {
          // Convert markdown **bold** to HTML <strong>
          const formattedPoint = point.replace(
            /\*\*(.*?)\*\*/g,
            "<strong>$1</strong>"
          )
          html += `<div style="margin: 4px 0; padding-left: 8px;">• ${formattedPoint}</div>`
        })
        if (summary.keyPoints.length > 3) {
          html += `<div style="color: #7f8c8d; font-style: italic; padding-left: 8px;">...and ${
            summary.keyPoints.length - 3
          } more</div>`
        }
        html += `</div>`
      }

      if (summary.clinicalPearls && summary.clinicalPearls.length > 0) {
        html += `<div style="margin-bottom: 8px;"><strong>💎 Clinical Pearls:</strong><br>`
        summary.clinicalPearls.slice(0, 2).forEach(pearl => {
          // Convert markdown **bold** to HTML <strong>
          const formattedPearl = pearl.replace(
            /\*\*(.*?)\*\*/g,
            "<strong>$1</strong>"
          )
          html += `<div style="margin: 4px 0; padding-left: 8px;">• ${formattedPearl}</div>`
        })
        if (summary.clinicalPearls.length > 2) {
          html += `<div style="color: #7f8c8d; font-style: italic; padding-left: 8px;">...and ${
            summary.clinicalPearls.length - 2
          } more</div>`
        }
        html += `</div>`
      }

      return html || "Summary content available"
    }

    async getSummaryHistory(pageUrl) {
      try {
        // Use the aiTutor's unified storage method
        const responses = await this.aiTutor.getPageAIResponses(
          pageUrl,
          "summary"
        )

        // Convert to expected format for display
        return responses.map(response => ({
          content: response.response.parsed || response.response.raw,
          timestamp: response.timestamp,
          focus: response.request.focus || "general",
        }))
      } catch (error) {
        console.error("Error getting summary history:", error)
        return []
      }
    }

    // Get the most recent summary for this page (any type) from unified storage
    async getLastSummary(pageUrl) {
      try {
        const responses = await this.aiTutor.getPageAIResponses(
          pageUrl,
          "summary"
        )
        if (responses.length > 0) {
          const latest = responses[0] // Already sorted by timestamp, most recent first
          return {
            content: latest.response.parsed || latest.response.raw,
            timestamp: latest.timestamp,
            focus: latest.request.focus || "general",
          }
        }
        return null
      } catch (error) {
        console.error("Error getting last summary:", error)
        return null
      }
    }

    // Helper method to format camelCase/snake_case field names into readable titles
    formatFieldNameAsTitle(fieldName) {
      return (
        fieldName
          // Handle camelCase: keyDistinguishers -> key Distinguishers
          .replace(/([a-z])([A-Z])/g, "$1 $2")
          // Handle snake_case: imaging_approach -> imaging approach
          .replace(/_/g, " ")
          // Capitalize first letter of each word
          .replace(/\b\w/g, letter => letter.toUpperCase())
      )
    }

    // Helper method to get appropriate emoji for field names
    getEmojiForField(fieldName) {
      const fieldLower = fieldName.toLowerCase()

      if (
        fieldLower.includes("differential") ||
        fieldLower.includes("diagnos")
      ) {
        return "🔍"
      } else if (
        fieldLower.includes("approach") ||
        fieldLower.includes("workflow")
      ) {
        return "📋"
      } else if (
        fieldLower.includes("pearl") ||
        fieldLower.includes("tip") ||
        fieldLower.includes("distinguisher")
      ) {
        return "💎"
      } else if (
        fieldLower.includes("point") ||
        fieldLower.includes("key") ||
        fieldLower.includes("main")
      ) {
        return "🎯"
      } else if (fieldLower.includes("imaging")) {
        return "🔬"
      } else if (fieldLower.includes("clinical")) {
        return "🩺"
      } else {
        return "📝" // Default emoji
      }
    }

    // Check if a specific summary type exists for this page
    async getCachedSummaryByType(pageUrl, length, focus) {
      try {
        const allGMKeys = await GM.listValues()
        const pageContent = this.aiTutor.extractPageContent()
        const contentHash = this.aiTutor.getContentHash(pageContent)

        // Build the expected cache key pattern for this specific type
        const options = { length, focus }
        const expectedCacheKey = `ai_cache_summary_${pageUrl}_${contentHash}_${JSON.stringify(
          options
        )}`

        console.log("🔍 Looking for cached summary type:", {
          length,
          focus,
          expectedCacheKey: expectedCacheKey.substring(0, 60) + "...",
        })

        // Check if this exact type exists
        const cached = await GM.getValue(expectedCacheKey, null)
        if (cached) {
          const parsedCache = JSON.parse(cached)
          if (parsedCache.timestamp && parsedCache.content) {
            console.log("✅ Found cached summary for this type")
            return {
              summary: parsedCache.content,
              timestamp: parsedCache.timestamp,
              cacheKey: expectedCacheKey,
              age: Date.now() - parsedCache.timestamp,
            }
          }
        }

        console.log("❌ No cached summary found for this type")
        return null
      } catch (error) {
        console.error("Error checking cached summary by type:", error)
        return null
      }
    }

    // Helper method to parse and format any response content
    parseAndFormatResponse(content) {
      try {
        // If content is already an object (parsed), format it directly
        if (typeof content === "object" && content !== null) {
          return this.formatSummaryContent(content)
        }

        // If content is a string, try to parse it first
        if (typeof content === "string") {
          // Try to parse as JSON first
          try {
            const parsed = JSON.parse(content)
            return this.formatSummaryContent(parsed)
          } catch (jsonError) {
            // If JSON parsing fails, try using the summary parser
            const parsed = this.aiTutor.parseSummaryResponse(content)
            return this.formatSummaryContent(parsed)
          }
        }

        // Fallback for any other case
        console.warn("Unknown content type:", typeof content)
        return `<div style="color: #95a5a6; padding: 20px; text-align: center;">Content format not recognized</div>`
      } catch (error) {
        console.error("Error parsing and formatting response:", error)
        return `<div style="color: #dc3545; padding: 20px; text-align: center;">Error displaying content: ${error.message}</div>`
      }
    }

    async testApiKey() {
      if (!this.aiTutor.hasApiKey()) {
        alert("❌ No API key configured. Please set up your API key first.")
        return
      }

      try {
        const testResponse = await this.aiTutor.callMistralAPI(
          'Test message - please respond with "OK"',
          "mistral-small-latest"
        )
        if (testResponse && testResponse.content) {
          alert("✅ API key is working correctly!")
        } else {
          alert("⚠️ API key test returned unexpected response.")
        }
      } catch (error) {
        alert(`❌ API key test failed: ${error.message}`)
      }
    }

    async showAllDataViewer() {
      console.log("🔍 showAllDataViewer called")
      try {
        console.log("🔍 Getting ALL GM keys (including AI cache)...")

        // Get ALL GM keys, not just prefixed ones
        const allGMKeys = await GM.listValues()
        console.log("🔍 All GM keys found:", allGMKeys)

        // Separate prefixed app data from AI cache
        const appDataKeys = allGMKeys.filter(key =>
          key.startsWith("ra_tutor_gdpr_")
        )
        const aiCacheKeys = allGMKeys.filter(key => key.startsWith("ai_cache_"))
        const apiKeyKeys = allGMKeys.filter(key => key === "mistral_api_key")
        const otherKeys = allGMKeys.filter(
          key =>
            !key.startsWith("ra_tutor_gdpr_") &&
            !key.startsWith("ai_cache_") &&
            key !== "mistral_api_key"
        )

        console.log("🔍 Categorized keys:", {
          appData: appDataKeys.length,
          aiCache: aiCacheKeys.length,
          apiKey: apiKeyKeys.length,
          other: otherKeys.length,
        })

        // Count Q&A history entries
        const qaHistoryKeys = appDataKeys.filter(key =>
          key.includes("qa_history_")
        )
        console.log("🔍 Q&A History keys found:", qaHistoryKeys.length)

        if (allGMKeys.length === 0) {
          console.log("� No keys found at all")
          this.showDataModal(
            "📊 All Stored Data",
            `
            <div style="background: #fd7e14; padding: 15px; border-radius: 8px; margin: 10px 0; color: white;">
              <strong>ℹ️ No Data Found</strong><br>
              No data keys found in GM storage.<br>
              This could mean you haven't used the extension yet.
            </div>
          `
          )
          return
        }

        const dataPreview = {}

        // Load app data
        for (const key of appDataKeys) {
          const cleanKey = key.replace("ra_tutor_gdpr_", "")
          console.log("🔍 Loading app data for key:", cleanKey)
          const data = await this.dataManager.loadData(cleanKey, {})
          dataPreview[`APP_DATA_${cleanKey}`] = data
        }

        // Load AI cache data
        for (const key of aiCacheKeys) {
          console.log("🔍 Loading AI cache for key:", key)
          try {
            const cached = await GM.getValue(key, null)
            if (cached) {
              const parsedCache = JSON.parse(cached)
              const cleanKey = key.replace("ai_cache_", "")
              dataPreview[`AI_CACHE_${cleanKey}`] = {
                content: parsedCache.content,
                timestamp: parsedCache.timestamp,
                age: this.aiTutor.formatTimeAgo(parsedCache.timestamp),
                size: JSON.stringify(parsedCache.content).length,
                type: cleanKey.startsWith("summary_")
                  ? "Summary"
                  : cleanKey.startsWith("qa_")
                  ? "Q&A"
                  : "Unknown",
              }
            } else {
              dataPreview[`AI_CACHE_${key.replace("ai_cache_", "")}`] = {
                error: "No cached data found",
              }
            }
          } catch (error) {
            console.error("Error loading cache key:", key, error)
            dataPreview[`AI_CACHE_${key.replace("ai_cache_", "")}`] = {
              error: `Error loading cache: ${error.message}`,
            }
          }
        }

        // Load API key info
        if (apiKeyKeys.length > 0) {
          const apiKey = await GM.getValue("mistral_api_key", null)
          dataPreview["API_KEY_INFO"] = {
            configured: !!apiKey,
            preview: apiKey
              ? `${apiKey.substring(0, 8)}...${apiKey.substring(
                  apiKey.length - 4
                )}`
              : "Not set",
          }
        }

        // Load other keys
        for (const key of otherKeys) {
          console.log("🔍 Loading other data for key:", key)
          try {
            const data = await GM.getValue(key, null)
            dataPreview[`OTHER_${key}`] = data
          } catch (error) {
            dataPreview[`OTHER_${key}`] = "Error loading data"
          }
        }

        // Create formatted data display
        let formattedData = ""

        // Show app data first
        const appDataEntries = Object.entries(dataPreview).filter(([key]) =>
          key.startsWith("APP_DATA_")
        )
        if (appDataEntries.length > 0) {
          formattedData += `<div style="margin: 10px 0; padding: 10px; background: #1a3a6b; border-radius: 6px;">
            <strong>📚 Application Data (${appDataEntries.length} items):</strong><br>`

          appDataEntries.forEach(([key, data]) => {
            const cleanKey = key.replace("APP_DATA_", "")
            if (cleanKey === "reading_progress") {
              const today = new Date().toISOString().split("T")[0]
              const todayPages = data.dailyPagesRead
                ? data.dailyPagesRead[today] || 0
                : 0
              formattedData += `• Reading Progress: ${todayPages} pages today, ${
                data.apiCallsTotal || 0
              } API calls<br>`
            } else if (cleanKey.startsWith("qa_history_")) {
              // Q&A History entry
              const qaCount = Array.isArray(data) ? data.length : 0
              const pageHash = cleanKey.replace("qa_history_", "")
              const latestEntry = qaCount > 0 ? data[0] : null
              const pageTitle = latestEntry
                ? latestEntry.pageTitle
                : "Unknown Page"
              formattedData += `• Q&A History (${pageTitle.substring(
                0,
                30
              )}...): ${qaCount} questions<br>`
            } else {
              formattedData += `• ${cleanKey}: ${
                JSON.stringify(data).length
              } bytes<br>`
            }
          })
          formattedData += `</div>`
        }

        // Show AI cache data
        const aiCacheEntries = Object.entries(dataPreview).filter(([key]) =>
          key.startsWith("AI_CACHE_")
        )
        if (aiCacheEntries.length > 0) {
          formattedData += `<div style="margin: 10px 0; padding: 10px; background: #1a3a6b; border-radius: 6px;">
            <strong>🤖 AI Cache (${aiCacheEntries.length} items):</strong><br>`

          aiCacheEntries.forEach(([key, data]) => {
            const cacheKey = key.replace("AI_CACHE_", "")
            if (data && typeof data === "object" && !data.error) {
              formattedData += `• <button onclick="window.raTutor.ui.aiTutor.viewCacheContent('${cacheKey}', '${data.type}')" style="background: #7198f8; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 10px; margin-right: 6px;">View</button>${cacheKey}: ${data.type} (${data.age}, ${data.size} bytes)<br>`
            } else if (data && data.error) {
              formattedData += `• ${cacheKey}: ${data.error}<br>`
            } else {
              formattedData += `• ${cacheKey}: Invalid data format<br>`
            }
          })
          formattedData += `</div>`
        }

        // Show API key info
        if (dataPreview.API_KEY_INFO) {
          const apiInfo = dataPreview.API_KEY_INFO
          formattedData += `<div style="margin: 10px 0; padding: 10px; background: #1a3a6b; border-radius: 6px;">
            <strong>🔑 API Key:</strong> ${
              apiInfo.configured ? `✅ ${apiInfo.preview}` : "❌ Not configured"
            }<br>
          </div>`
        }

        // Show other data
        const otherEntries = Object.entries(dataPreview).filter(([key]) =>
          key.startsWith("OTHER_")
        )
        if (otherEntries.length > 0) {
          formattedData += `<div style="margin: 10px 0; padding: 10px; background: #1a3a6b; border-radius: 6px;">
            <strong>📦 Other Data (${otherEntries.length} items):</strong><br>`
          otherEntries.forEach(([key, data]) => {
            formattedData += `• ${key.replace("OTHER_", "")}: ${
              JSON.stringify(data).length
            } bytes<br>`
          })
          formattedData += `</div>`
        }

        const totalSize = JSON.stringify(dataPreview).length
        const dataJson = JSON.stringify(dataPreview, null, 2)

        // Calculate Q&A statistics
        let totalQAEntries = 0
        let totalPages = 0
        let totalSummaries = 0
        let totalQACache = 0

        // Count Q&A history entries
        Object.entries(dataPreview).forEach(([key, data]) => {
          if (key.startsWith("APP_DATA_qa_history_")) {
            totalPages++
            if (Array.isArray(data)) {
              totalQAEntries += data.length
            }
          }
        })

        // Count AI cache entries by type
        Object.entries(dataPreview).forEach(([key, data]) => {
          if (key.startsWith("AI_CACHE_")) {
            if (data && data.type === "Summary") {
              totalSummaries++
            } else if (data && data.type === "Q&A") {
              totalQACache++
            }
          }
        })

        // Create modal to show data
        this.showDataModal(
          "📊 All Stored Data",
          `
          <div style="background: #1a3a6b; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <strong>📊 Storage Summary:</strong><br>
            <strong>🔑 API Key:</strong> ${
              this.aiTutor.hasApiKey() ? "✅ Configured" : "❌ Not set"
            }<br>
            <strong>📦 Total Keys:</strong> ${allGMKeys.length}<br>
            <strong>❓ Q&A Entries:</strong> ${totalQAEntries} questions across ${totalPages} pages<br>
            <strong>🤖 AI Cache:</strong> ${totalSummaries} summaries, ${totalQACache} Q&A responses<br>
            <strong>💾 Estimated Size:</strong> ~${Math.round(
              totalSize / 1024
            )}KB
          </div>
          
          ${formattedData}
          
          <details style="margin-top: 15px;">
            <summary style="cursor: pointer; color: #7198f8; font-weight: bold;">🔧 Show Raw JSON Data</summary>
            <div style="background: #0f2142; padding: 15px; border-radius: 8px; max-height: 300px; overflow-y: auto; margin-top: 10px;">
              <pre style="font-size: 10px; color: #b0bec5; white-space: pre-wrap; word-break: break-all;">${dataJson}</pre>
            </div>
          </details>
        `
        )
      } catch (error) {
        console.error("🔍 Error in showAllDataViewer:", error)
        alert(`❌ Error viewing data: ${error.message}`)
      }
    }

    async exportAllData() {
      console.log("📤 exportAllData called")
      try {
        const allKeys = await GM.listValues()

        // Get all unified AI responses
        const responseKeys = allKeys.filter(key =>
          key.startsWith("ai_response_")
        )
        const tokenLogKeys = allKeys.filter(key => key.startsWith("token_log_"))
        const otherKeys = allKeys.filter(
          key =>
            !key.startsWith("ai_response_") &&
            !key.startsWith("token_log_") &&
            key !== "mistral_api_key" &&
            key !== "ra_tutor_language"
        )

        // Prepare spreadsheet-friendly data structure
        const exportData = {
          metadata: {
            exportDate: new Date().toISOString(),
            scriptVersion: GM.info ? GM.info.script.version : "0.0.1",
            totalResponses: responseKeys.length,
            totalTokenLogs: tokenLogKeys.length,
          },

          // Spreadsheet-ready Q&A data
          questions_and_answers: [],

          // Spreadsheet-ready summaries data
          summaries: [],

          // Token usage logs for analysis
          token_usage: [],

          // Settings and preferences
          settings: {
            apiKeyConfigured: this.aiTutor.hasApiKey(),
            language: await GM.getValue("ra_tutor_language", "english"),
          },
        }

        // Process AI responses into spreadsheet format
        for (const key of responseKeys) {
          try {
            const data = await GM.getValue(key, null)
            if (data) {
              const response = JSON.parse(data)

              if (response.type === "qa") {
                exportData.questions_and_answers.push({
                  date: new Date(response.timestamp)
                    .toISOString()
                    .split("T")[0],
                  time: new Date(response.timestamp)
                    .toISOString()
                    .split("T")[1]
                    .split(".")[0],
                  page_title: response.pageTitle || "Unknown",
                  page_url: response.pageUrl || "Unknown",
                  question: response.request.question || "",
                  answer:
                    response.response.raw || response.response.parsed || "",
                  model_used: response.metadata?.model || "unknown",
                  question_length: response.metadata?.questionLength || 0,
                  language: response.request.languageInstruction
                    ? "non-english"
                    : "english",
                })
              } else if (response.type === "summary") {
                exportData.summaries.push({
                  date: new Date(response.timestamp)
                    .toISOString()
                    .split("T")[0],
                  time: new Date(response.timestamp)
                    .toISOString()
                    .split("T")[1]
                    .split(".")[0],
                  page_title: response.pageTitle || "Unknown",
                  page_url: response.pageUrl || "Unknown",
                  summary_focus: response.request.focus || "general",
                  summary_length: response.request.length || "medium",
                  content_preview:
                    (response.response.raw || "").substring(0, 200) + "...",
                  model_used: response.metadata?.model || "unknown",
                  language: response.request.languageInstruction
                    ? "non-english"
                    : "english",
                })
              }
            }
          } catch (error) {
            console.warn("Error processing response:", error)
          }
        }

        // Process token usage logs
        for (const key of tokenLogKeys) {
          try {
            const data = await GM.getValue(key, null)
            if (data) {
              const log = JSON.parse(data)
              exportData.token_usage.push({
                date: new Date(log.timestamp).toISOString().split("T")[0],
                time: new Date(log.timestamp)
                  .toISOString()
                  .split("T")[1]
                  .split(".")[0],
                type: log.type || "unknown",
                model: log.model || "unknown",
                page_url: log.pageUrl || "unknown",
                tokens_prompt: log.tokens?.prompt || 0,
                tokens_completion: log.tokens?.completion || 0,
                tokens_total: log.tokens?.total || 0,
                cost_usd: log.cost || 0,
              })
            }
          } catch (error) {
            console.warn("Error processing token log:", error)
          }
        }

        // Sort data by date for better readability
        exportData.questions_and_answers.sort(
          (a, b) =>
            new Date(b.date + "T" + b.time) - new Date(a.date + "T" + a.time)
        )
        exportData.summaries.sort(
          (a, b) =>
            new Date(b.date + "T" + b.time) - new Date(a.date + "T" + a.time)
        )
        exportData.token_usage.sort(
          (a, b) =>
            new Date(b.date + "T" + b.time) - new Date(a.date + "T" + a.time)
        )

        // Create the export file
        const dataBlob = new Blob([JSON.stringify(exportData, null, 2)], {
          type: "application/json",
        })
        const url = URL.createObjectURL(dataBlob)

        const link = document.createElement("a")
        link.href = url
        link.download = `radiology-tutor-export-${
          new Date().toISOString().split("T")[0]
        }.json`
        document.body.appendChild(link)
        link.click()
        document.body.removeChild(link)
        URL.revokeObjectURL(url)

        alert(
          `✅ Data exported successfully!\n\n📊 Export Summary:\n• ${exportData.questions_and_answers.length} Q&A entries\n• ${exportData.summaries.length} summaries\n• ${exportData.token_usage.length} API usage logs\n\n💡 Tip: Open the JSON file in a text editor or import individual arrays into spreadsheet applications for analysis.`
        )
      } catch (error) {
        console.error("📤 Error in exportAllData:", error)
        alert(`❌ Error exporting data: ${error.message}`)
      }
    }

    async purgeDataKeepKey() {
      console.log("🗑️ purgeDataKeepKey called")
      if (
        confirm(
          "⚠️ This will delete all progress data but keep your API key. Continue?"
        )
      ) {
        try {
          // Clear all data except API key
          const allKeys = await this.dataManager.getAllKeys()
          for (const key of allKeys) {
            const cleanKey = key.replace("ra_tutor_", "")
            if (cleanKey !== "mistral_api_key") {
              await this.dataManager.deleteData(cleanKey)
            }
          }

          console.log("🔒 GDPR: Progress data purged, API key preserved")
          alert("✅ Progress data cleared. API key preserved.")
          this.switchTab(this.currentTab)
          this.updateSettingsContent()
        } catch (error) {
          console.error("🗑️ Error in purgeDataKeepKey:", error)
          alert(`❌ Error purging data: ${error.message}`)
        }
      }
    }

    async purgeAllData() {
      console.log("💥 purgeAllData called")

      // First confirmation - make it scary
      if (
        !confirm(
          "🚨 DANGER ZONE 🚨\n\nThis will PERMANENTLY DELETE:\n• All your reading progress\n• All your quiz results\n• Your API key\n• ALL stored data\n\nThis action CANNOT be undone!\n\nAre you absolutely sure?"
        )
      ) {
        return
      }

      // Second confirmation - even scarier
      if (
        !confirm(
          "⚠️ FINAL WARNING ⚠️\n\nYou are about to destroy ALL data.\nThere is NO way to recover this.\n\nType-to-confirm: Are you 100% certain?\n\nClick OK to PERMANENTLY DELETE EVERYTHING\nClick Cancel to abort"
        )
      ) {
        return
      }

      try {
        console.log("💥 Proceeding with nuclear option...")
        await this.clearAllData()
        this.updateSettingsContent()
        alert("💥 Everything has been permanently deleted.")
      } catch (error) {
        console.error("💥 Error in purgeAllData:", error)
        alert(`❌ Error purging all data: ${error.message}`)
      }
    }

    showDataModal(title, content) {
      // Remove existing modal if any
      const existingModal = document.querySelector(".data-modal-overlay")
      if (existingModal) {
        existingModal.remove()
      }

      const overlay = document.createElement("div")
      overlay.className = "data-modal-overlay"
      overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 100000;
        display: flex; align-items: center; justify-content: center;
      `

      const modal = document.createElement("div")
      modal.style.cssText = `
        background: #123262; color: white; padding: 20px; border-radius: 12px;
        max-width: 80%; max-height: 80%; overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      `

      modal.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #7198f8;">${title}</h3>
          <button id="close-modal" style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">✕ Close</button>
        </div>
        <div>${content}</div>
      `

      overlay.appendChild(modal)
      document.body.appendChild(overlay)

      // Close modal handlers
      const closeBtn = modal.querySelector("#close-modal")
      closeBtn.addEventListener("click", () => overlay.remove())
      overlay.addEventListener("click", e => {
        if (e.target === overlay) overlay.remove()
      })
    }

    // Helper method to normalize URLs for comparison (extract just the path)
    normalizeUrlForComparison(url) {
      if (!url) return ""

      // If it's already just a path, return it
      if (url.startsWith("/")) {
        return url
      }

      // If it's a full URL, extract the pathname
      try {
        const urlObj = new URL(url)
        return urlObj.pathname
      } catch (error) {
        console.warn("Could not parse URL:", url)
        return url
      }
    }

    // Helper method to get the last summary for a page
    async getLastSummary(pageUrl) {
      try {
        const allGMKeys = await GM.listValues()
        const aiCacheKeys = allGMKeys.filter(key =>
          key.startsWith("ai_cache_summary_")
        )

        // Normalize the input pageUrl to just the path for comparison
        const normalizedPageUrl = this.normalizeUrlForComparison(pageUrl)

        console.log("🔍 getLastSummary - pageUrl:", pageUrl)
        console.log("🔍 getLastSummary - normalizedPageUrl:", normalizedPageUrl)
        console.log("🔍 getLastSummary - found cache keys:", aiCacheKeys.length)

        const pageSummaries = []
        for (const key of aiCacheKeys) {
          try {
            const cached = await GM.getValue(key, null)
            if (cached) {
              const parsedCache = JSON.parse(cached)
              if (parsedCache.timestamp && parsedCache.content) {
                // Extract page info from cache key - the pageUrl should be directly in the key
                // Cache keys look like: ai_cache_summary_/musculoskeletal/arthritis/fractures-video-lesson_hash_options
                const keyParts = key.replace("ai_cache_summary_", "").split("_")
                let keyPageUrl = keyParts[0]

                // If the page URL contains slashes, they might be encoded or split across multiple parts
                // Let's try to reconstruct the full path
                if (keyParts.length > 2) {
                  // Find where the hash part starts (it's usually a long alphanumeric string)
                  const hashIndex = keyParts.findIndex(
                    part => part.length > 20 && /^[a-f0-9]+$/.test(part)
                  )
                  if (hashIndex > 0) {
                    keyPageUrl = keyParts.slice(0, hashIndex).join("_")
                  }
                }

                // Add back slashes if they were replaced with underscores
                if (!keyPageUrl.startsWith("/")) {
                  keyPageUrl = "/" + keyPageUrl.replace(/_/g, "/")
                }

                console.log("🔍 Comparing:", { keyPageUrl, normalizedPageUrl })

                // Compare the normalized URLs (both should be paths now)
                if (keyPageUrl === normalizedPageUrl) {
                  pageSummaries.push({
                    content: parsedCache.content,
                    timestamp: parsedCache.timestamp,
                    pageUrl: normalizedPageUrl,
                    cacheKey: key,
                  })
                  console.log("✅ Found matching summary:", {
                    timestamp: parsedCache.timestamp,
                  })
                }
              }
            }
          } catch (error) {
            console.warn("Error loading summary:", error)
          }
        }

        console.log(
          "🔍 getLastSummary - total matching summaries:",
          pageSummaries.length
        )

        // Sort by timestamp (newest first) and return the most recent
        pageSummaries.sort((a, b) => b.timestamp - a.timestamp)
        const lastSummary = pageSummaries.length > 0 ? pageSummaries[0] : null

        if (lastSummary) {
          console.log(
            "📋 Returning last summary from:",
            new Date(lastSummary.timestamp)
          )
        } else {
          console.log("❌ No matching summaries found")
        }

        return lastSummary
      } catch (error) {
        console.error("Error getting last summary:", error)
        return null
      }
    }

    // Helper method to get cached summary by specific type (length + focus)
    async getCachedSummaryByType(pageUrl, length, focus) {
      try {
        const allGMKeys = await GM.listValues()
        const aiCacheKeys = allGMKeys.filter(key =>
          key.startsWith("ai_cache_summary_")
        )

        // Normalize the input pageUrl to just the path for comparison
        const normalizedPageUrl = this.normalizeUrlForComparison(pageUrl)

        console.log("🔍 getCachedSummaryByType:", {
          pageUrl,
          normalizedPageUrl,
          length,
          focus,
        })

        for (const key of aiCacheKeys) {
          try {
            const cached = await GM.getValue(key, null)
            if (cached) {
              const parsedCache = JSON.parse(cached)
              if (
                parsedCache.timestamp &&
                parsedCache.content &&
                parsedCache.options
              ) {
                // Extract page info from cache key
                const keyParts = key.replace("ai_cache_summary_", "").split("_")
                let keyPageUrl = keyParts[0]

                // Reconstruct the full path like we did in getLastSummary
                if (keyParts.length > 2) {
                  const hashIndex = keyParts.findIndex(
                    part => part.length > 20 && /^[a-f0-9]+$/.test(part)
                  )
                  if (hashIndex > 0) {
                    keyPageUrl = keyParts.slice(0, hashIndex).join("_")
                  }
                }

                if (!keyPageUrl.startsWith("/")) {
                  keyPageUrl = "/" + keyPageUrl.replace(/_/g, "/")
                }

                console.log("🔍 Checking cache entry:", {
                  keyPageUrl,
                  normalizedPageUrl,
                  cacheOptions: parsedCache.options,
                  targetOptions: { length, focus },
                })

                // Check if this matches the page and summary type (use normalized URLs)
                if (
                  keyPageUrl === normalizedPageUrl &&
                  parsedCache.options.length === length &&
                  parsedCache.options.focus === focus
                ) {
                  console.log("✅ Found matching cached summary by type")
                  return {
                    summary: parsedCache.content,
                    timestamp: parsedCache.timestamp,
                    summaryType: `${length}_${focus}`,
                    pageUrl: normalizedPageUrl,
                    age: Date.now() - parsedCache.timestamp,
                    cacheKey: key,
                  }
                }
              }
            }
          } catch (error) {
            console.warn("Error loading summary:", error)
          }
        }

        console.log("❌ No cached summary found for this type")
        return null
      } catch (error) {
        console.error("Error getting cached summary by type:", error)
        return null
      }
    }

    // Helper method to get summary history for a page
    async getSummaryHistory(pageUrl) {
      try {
        const allGMKeys = await GM.listValues()
        const aiCacheKeys = allGMKeys.filter(key =>
          key.startsWith("ai_cache_summary_")
        )

        // Normalize the input pageUrl to just the path for comparison
        const normalizedPageUrl = this.normalizeUrlForComparison(pageUrl)

        const pageSummaries = []
        for (const key of aiCacheKeys) {
          try {
            const cached = await GM.getValue(key, null)
            if (cached) {
              const parsedCache = JSON.parse(cached)
              if (parsedCache.timestamp && parsedCache.content) {
                // Use the same URL extraction logic as getLastSummary
                const keyParts = key.replace("ai_cache_summary_", "").split("_")
                let keyPageUrl = keyParts[0]

                if (keyParts.length > 2) {
                  const hashIndex = keyParts.findIndex(
                    part => part.length > 20 && /^[a-f0-9]+$/.test(part)
                  )
                  if (hashIndex > 0) {
                    keyPageUrl = keyParts.slice(0, hashIndex).join("_")
                  }
                }

                if (!keyPageUrl.startsWith("/")) {
                  keyPageUrl = "/" + keyPageUrl.replace(/_/g, "/")
                }

                // Use normalized URL for comparison
                if (keyPageUrl === normalizedPageUrl) {
                  pageSummaries.push({
                    content: parsedCache.content,
                    timestamp: parsedCache.timestamp,
                    pageUrl: normalizedPageUrl,
                    options: parsedCache.options || {},
                    cacheKey: key,
                  })
                }
              }
            }
          } catch (error) {
            console.warn("Error loading summary:", error)
          }
        }

        // Sort by timestamp (newest first)
        pageSummaries.sort((a, b) => b.timestamp - a.timestamp)
        return pageSummaries
      } catch (error) {
        console.error("Error getting summary history:", error)
        return []
      }
    }

    // Helper method to parse and format response content
    parseAndFormatResponse(content) {
      if (!content) return "No content available"

      try {
        // If it's already an object, use it directly
        if (typeof content === "object") {
          return this.formatSummaryContent(content)
        }

        // Try to parse as JSON first
        const parsed = JSON.parse(content)
        return this.formatSummaryContent(parsed)
      } catch (error) {
        // If JSON parsing fails, try the aiTutor's parser
        try {
          if (this.aiTutor && this.aiTutor.parseSummaryResponse) {
            const parsed = this.aiTutor.parseSummaryResponse(content)
            return this.formatSummaryContent(parsed)
          }
        } catch (parseError) {
          console.warn("Could not parse response:", parseError)
        }

        // Fallback: return content as-is with basic formatting
        return content.replace(/\n/g, "<br>")
      }
    }

    // Helper method to format summary content for display
    formatSummaryContent(summary) {
      if (!summary) return "No summary content available"

      // If it's a string, return it directly
      if (typeof summary === "string") {
        return summary.replace(/\n/g, "<br>")
      }

      let html = ""

      // Format key points
      if (summary.keyPoints && summary.keyPoints.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <strong style="color: #7198f8;">🎯 Key Points:</strong><br>
          ${summary.keyPoints.map(point => `• ${point}`).join("<br>")}
        </div>`
      }

      // Format clinical pearls
      if (summary.clinicalPearls && summary.clinicalPearls.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <strong style="color: #7198f8;">💎 Clinical Pearls:</strong><br>
          ${summary.clinicalPearls.map(pearl => `• ${pearl}`).join("<br>")}
        </div>`
      }

      // Format differentials
      if (summary.differentials && summary.differentials.length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <strong style="color: #7198f8;">🔍 Differential Diagnoses:</strong><br>
          ${summary.differentials.map(diff => `• ${diff}`).join("<br>")}
        </div>`
      }

      return html || summary.toString().replace(/\n/g, "<br>")
    }

    // ========================================
    // 💰 PRICING MANAGEMENT UI METHODS
    // ========================================

    async showPricingOverview() {
      try {
        const allPricing = await this.aiTutor.getAllPricing()

        let pricingHTML = `
          <div style="background: #1a3a6b; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <strong>💰 Current Pricing Configuration:</strong><br>
            <div style="margin-top: 10px;">
        `

        // Show effective pricing (default + custom overrides)
        Object.entries(allPricing.effective).forEach(([model, pricing]) => {
          const isCustom = allPricing.custom[model] ? true : false
          pricingHTML += `
            <div style="margin-bottom: 8px; padding: 8px; background: #123262; border-radius: 6px; ${
              isCustom ? "border-left: 4px solid #ffc107;" : ""
            }">
              <div style="font-weight: bold; color: #7198f8; margin-bottom: 4px;">
                ${model} ${isCustom ? "(Custom)" : "(Default)"}
              </div>
              <div style="font-size: 11px; color: #b0bec5;">
                Input: $${pricing.input}/1K tokens • Output: $${
            pricing.output
          }/1K tokens
              </div>
              ${
                isCustom && pricing.lastUpdated
                  ? `
                <div style="font-size: 9px; color: #7f8c8d; margin-top: 2px;">
                  Updated: ${new Date(pricing.lastUpdated).toLocaleString()}
                </div>
              `
                  : ""
              }
            </div>
          `
        })

        pricingHTML += `
            </div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(113, 152, 248, 0.1); border-radius: 6px; border-left: 4px solid #7198f8;">
              <div style="font-size: 11px; color: #b0bec5; line-height: 1.4;">
                <strong style="color: #7198f8;">💡 About Pricing:</strong><br>
                • Default pricing is built into the script<br>
                • Custom pricing overrides defaults for specific models<br>
                • Costs are calculated per 1,000 tokens (input + output)<br>
                • Update pricing when Mistral AI changes their rates
              </div>
            </div>
          </div>
        `

        this.showDataModal("💰 AI Pricing Overview", pricingHTML)
      } catch (error) {
        console.error("Error showing pricing overview:", error)
        alert(`❌ Error loading pricing information: ${error.message}`)
      }
    }

    async showPricingEditor() {
      try {
        const allPricing = await this.aiTutor.getAllPricing()

        // Create pricing editor modal
        const overlay = document.createElement("div")
        overlay.className = "pricing-editor-overlay"
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          z-index: 10001;
          display: flex;
          align-items: center;
          justify-content: center;
        `

        const modal = document.createElement("div")
        modal.style.cssText = `
          background: white;
          padding: 30px;
          border-radius: 15px;
          max-width: 600px;
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        `

        let modelsHTML = ""
        Object.entries(allPricing.effective).forEach(([model, pricing]) => {
          const isCustom = allPricing.custom[model] ? true : false
          modelsHTML += `
            <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; ${
              isCustom ? "border-left: 5px solid #ffc107;" : ""
            }">
              <h4 style="margin: 0 0 10px 0; color: #333;">${model} ${
            isCustom ? "(Custom)" : "(Default)"
          }</h4>
              <div style="display: flex; gap: 15px; margin-bottom: 10px;">
                <div style="flex: 1;">
                  <label style="display: block; margin-bottom: 5px; font-weight: bold;">Input Cost ($/1K tokens):</label>
                  <input type="number" step="0.000001" id="input-${model.replace(
                    /[^a-zA-Z0-9]/g,
                    "_"
                  )}" 
                         value="${
                           pricing.input
                         }" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
                <div style="flex: 1;">
                  <label style="display: block; margin-bottom: 5px; font-weight: bold;">Output Cost ($/1K tokens):</label>
                  <input type="number" step="0.000001" id="output-${model.replace(
                    /[^a-zA-Z0-9]/g,
                    "_"
                  )}" 
                         value="${
                           pricing.output
                         }" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px;">
                </div>
              </div>
              <button class="update-model-pricing" data-model="${model}" 
                      style="padding: 6px 12px; background: #7198f8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                ${isCustom ? "Update Custom Pricing" : "Set Custom Pricing"}
              </button>
              ${
                isCustom
                  ? `
                <button class="reset-model-pricing" data-model="${model}" 
                        style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 10px;">
                  Reset to Default
                </button>
              `
                  : ""
              }
            </div>
          `
        })

        modal.innerHTML = `
          <h3 style="margin-top: 0; color: #333;">💰 Update AI Pricing</h3>
          <p style="color: #666; line-height: 1.5;">
            Update pricing to match Mistral AI's current rates. Custom pricing will override default values.
          </p>
          
          <div style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
            ${modelsHTML}
          </div>
          
          <div style="margin: 20px 0; padding: 15px; background: #e3f2fd; border-radius: 8px; font-size: 13px; color: #1976d2;">
            <strong>💡 Tip:</strong> Check <a href="https://mistral.ai/technology/#pricing" target="_blank" style="color: #1976d2;">Mistral AI's pricing page</a> for the latest rates.
          </div>
          
          <div style="display: flex; gap: 10px; margin-top: 25px;">
            <button id="close-pricing-editor" style="flex: 1; padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer;">
              Close
            </button>
          </div>
        `

        overlay.appendChild(modal)
        document.body.appendChild(overlay)

        // Add event listeners
        modal.addEventListener("click", async e => {
          if (e.target.classList.contains("update-model-pricing")) {
            const model = e.target.dataset.model
            const modelKey = model.replace(/[^a-zA-Z0-9]/g, "_")
            const inputCost = document.getElementById(`input-${modelKey}`).value
            const outputCost = document.getElementById(
              `output-${modelKey}`
            ).value

            if (
              await this.aiTutor.updateModelPricing(
                model,
                inputCost,
                outputCost
              )
            ) {
              e.target.textContent = "✅ Updated!"
              e.target.style.background = "#28a745"
              setTimeout(() => {
                e.target.textContent = "Update Custom Pricing"
                e.target.style.background = "#7198f8"
              }, 2000)
            } else {
              alert("❌ Error updating pricing. Please try again.")
            }
          } else if (e.target.classList.contains("reset-model-pricing")) {
            const model = e.target.dataset.model
            // Remove custom pricing for this model
            const customPricing = await GM.getValue("mistral_pricing", "{}")
            const pricing = JSON.parse(customPricing)
            delete pricing[model]
            await GM.setValue("mistral_pricing", JSON.stringify(pricing))

            // Reload the editor
            overlay.remove()
            this.showPricingEditor()
          }
        })

        document
          .getElementById("close-pricing-editor")
          .addEventListener("click", () => {
            overlay.remove()
          })

        // Close on overlay click
        overlay.addEventListener("click", e => {
          if (e.target === overlay) {
            overlay.remove()
          }
        })
      } catch (error) {
        console.error("Error showing pricing editor:", error)
        alert(`❌ Error opening pricing editor: ${error.message}`)
      }
    }

    async updateSettingsContent() {
      // Update API key status only
      const apiKeyStatus = document.getElementById("api-key-status")
      if (apiKeyStatus) {
        const hasKey = this.aiTutor.hasApiKey()
        apiKeyStatus.innerHTML = hasKey
          ? `✅ Configured: ${this.aiTutor.apiKey.substring(0, 8)}...****`
          : "❌ Not configured"
      }

      // Update pricing status
      const pricingStatus = document.getElementById("pricing-status")
      if (pricingStatus) {
        try {
          const allPricing = await this.aiTutor.getAllPricing()
          const customCount = Object.keys(allPricing.custom).length
          const totalCount = Object.keys(allPricing.effective).length

          pricingStatus.innerHTML =
            customCount > 0
              ? `✅ ${customCount}/${totalCount} models have custom pricing`
              : `📋 Using default pricing for all ${totalCount} models`
        } catch (error) {
          pricingStatus.innerHTML = "❌ Error loading pricing status"
        }
      }

      // Update language selection
      const languageSelect = document.getElementById("ai-language-select")
      if (languageSelect) {
        const savedLanguage = await this.getLanguagePreference()
        languageSelect.value = savedLanguage
      }
    }
  }

  // ========================================
  // 🚀 MAIN APPLICATION
  // ========================================
  class RadiologyAssistantTutor {
    constructor() {
      this.dataManager = new DataManager()
      this.aiTutor = new AITutor()
      this.ui = new UIManager(this.aiTutor, this.dataManager)
    }

    init() {
      console.log("🧠 Radiology Assistant Personal Tutor - Initializing...")
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => this.start())
      } else {
        this.start()
      }
    }

    async start() {
      try {
        console.log("🧠 Starting Radiology Assistant Personal Tutor...")
        window.raTutor = this
        console.log("🔒 GDPR: Initializing AI Tutor...")
        await this.aiTutor.initialize()
        console.log(
          "🔒 AI Tutor initialization complete, API key status:",
          this.aiTutor.hasApiKey()
        )

        // Initialize UI after AITutor is ready
        this.ui.init()

        console.log("✅ Radiology Assistant Personal Tutor - Ready!")
      } catch (error) {
        console.error("❌ Error initializing tutor:", error)
      }
    }
  }

  // ========================================
  // 🎯 INITIALIZATION
  // ========================================
  const tutor = new RadiologyAssistantTutor()

  tutor.init()
})()
